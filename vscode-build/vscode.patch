diff --git a/build/gulpfile.compile.js b/build/gulpfile.compile.js
index c4947e76cbf..c2dd4189229 100644
--- a/build/gulpfile.compile.js
+++ b/build/gulpfile.compile.js
@@ -22,7 +22,9 @@ function makeCompileBuildTask(disableMangle) {
 }
 
 // Full compile, including nls and inline sources in sourcemaps, mangling, minification, for build
-const compileBuildTask = task.define('compile-build', makeCompileBuildTask(false));
+// The `true` here is to disable mangling. Minification still happens.
+// For some reason the mangling was causing the build to completely hang on my machine.
+const compileBuildTask = task.define('compile-build', makeCompileBuildTask(true));
 gulp.task(compileBuildTask);
 exports.compileBuildTask = compileBuildTask;
 
diff --git a/build/gulpfile.vscode.web.js b/build/gulpfile.vscode.web.js
index 50c7e6fb631..629a119108b 100644
--- a/build/gulpfile.vscode.web.js
+++ b/build/gulpfile.vscode.web.js
@@ -186,7 +186,7 @@ function packageTask(sourceFolderName, destinationFolderName) {
 		const json = require('gulp-json-editor');
 
 		const src = gulp.src(sourceFolderName + '/**', { base: '.' })
-			.pipe(rename(function (path) { path.dirname = path.dirname.replace(new RegExp('^' + sourceFolderName), 'out'); }));
+			.pipe(rename(function (path) { path.dirname = path.dirname.replace(new RegExp('^' + sourceFolderName), 'vscode'); }));
 
 		const extensions = gulp.src('.build/web/extensions/**', { base: '.build/web', dot: true });
 
diff --git a/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json b/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json
deleted file mode 100644
index 9e26dfeeb6e..00000000000
--- a/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json
+++ /dev/null
@@ -1 +0,0 @@
-{}
\ No newline at end of file
diff --git a/package.json b/package.json
index 2103fe1fe1a..92954953615 100644
--- a/package.json
+++ b/package.json
@@ -96,10 +96,10 @@
     "kerberos": "^2.0.1",
     "minimist": "^1.2.6",
     "native-is-elevated": "0.7.0",
-    "native-keymap": "^3.3.5",
     "native-watchdog": "^1.4.1",
     "node-pty": "1.1.0-beta11",
     "tas-client-umd": "0.2.0",
+    "utopia-vscode-common": "file:../../utopia-vscode-common",
     "v8-inspect-profiler": "^0.1.1",
     "vscode-oniguruma": "1.7.0",
     "vscode-regexpp": "^3.1.0",
diff --git a/product.json b/product.json
index 27ae53fe16b..83637043bdc 100644
--- a/product.json
+++ b/product.json
@@ -1,84 +1,9 @@
 {
-	"nameShort": "Code - OSS",
-	"nameLong": "Code - OSS",
-	"applicationName": "code-oss",
-	"dataFolderName": ".vscode-oss",
-	"win32MutexName": "vscodeoss",
-	"licenseName": "MIT",
-	"licenseUrl": "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
-	"serverLicenseUrl": "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
-	"serverGreeting": [],
-	"serverLicense": [],
-	"serverLicensePrompt": "",
-	"serverApplicationName": "code-server-oss",
-	"serverDataFolderName": ".vscode-server-oss",
-	"tunnelApplicationName": "code-tunnel-oss",
-	"win32DirName": "Microsoft Code OSS",
-	"win32NameVersion": "Microsoft Code OSS",
-	"win32RegValueName": "CodeOSS",
-	"win32x64AppId": "{{D77B7E06-80BA-4137-BCF4-654B95CCEBC5}",
-	"win32arm64AppId": "{{D1ACE434-89C5-48D1-88D3-E2991DF85475}",
-	"win32x64UserAppId": "{{CC6B787D-37A0-49E8-AE24-8559A032BE0C}",
-	"win32arm64UserAppId": "{{3AEBF0C8-F733-4AD4-BADE-FDB816D53D7B}",
-	"win32AppUserModelId": "Microsoft.CodeOSS",
-	"win32ShellNameShort": "C&ode - OSS",
-	"win32TunnelServiceMutex": "vscodeoss-tunnelservice",
-	"win32TunnelMutex": "vscodeoss-tunnel",
-	"darwinBundleIdentifier": "com.visualstudio.code.oss",
-	"linuxIconName": "code-oss",
-	"licenseFileName": "LICENSE.txt",
-	"reportIssueUrl": "https://github.com/microsoft/vscode/issues/new",
-	"nodejsRepository": "https://nodejs.org",
-	"urlProtocol": "code-oss",
-	"webviewContentExternalBaseUrlTemplate": "https://{{uuid}}.vscode-cdn.net/insider/ef65ac1ba57f57f2a3961bfe94aa20481caca4c6/out/vs/workbench/contrib/webview/browser/pre/",
-	"builtInExtensions": [
-		{
-			"name": "ms-vscode.js-debug-companion",
-			"version": "1.1.2",
-			"sha256": "e034b8b41beb4e97e02c70f7175bd88abe66048374c2bd629f54bb33354bc2aa",
-			"repo": "https://github.com/microsoft/vscode-js-debug-companion",
-			"metadata": {
-				"id": "99cb0b7f-7354-4278-b8da-6cc79972169d",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		},
-		{
-			"name": "ms-vscode.js-debug",
-			"version": "1.91.0",
-			"sha256": "53b99146c7fa280f00c74414e09721530c622bf3e5eac2c967ddfb9906b51c80",
-			"repo": "https://github.com/microsoft/vscode-js-debug",
-			"metadata": {
-				"id": "25629058-ddac-4e17-abba-74678e126c5d",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		},
-		{
-			"name": "ms-vscode.vscode-js-profile-table",
-			"version": "1.0.9",
-			"sha256": "3b62ee4276a2bbea3fe230f94b1d5edd915b05966090ea56f882e1e0ab53e1a6",
-			"repo": "https://github.com/microsoft/vscode-js-profile-visualizer",
-			"metadata": {
-				"id": "7e52b41b-71ad-457b-ab7e-0620f1fc4feb",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		}
-	]
-}
+	"productConfiguration": {
+		"nameShort": "Code Web",
+		"nameLong": "Code Web",
+		"applicationName": "code-web",
+		"dataFolderName": ".vscode-web",
+		"version": "1.91.1"
+	}
+}
\ No newline at end of file
diff --git a/src/vs/base/browser/dom.ts b/src/vs/base/browser/dom.ts
index 66d30c3aca3..25f12f879e4 100644
--- a/src/vs/base/browser/dom.ts
+++ b/src/vs/base/browser/dom.ts
@@ -495,8 +495,11 @@ export function getClientArea(element: HTMLElement, fallback?: HTMLElement): Dim
 	if (fallback) {
 		return getClientArea(fallback);
 	}
-
-	throw new Error('Unable to figure out browser width and height');
+ 	// this Error would prevent VSCode from loading inside Utopia if the browser tab is not in the foreground
+ 	// throw new Error('Unable to figure out browser width and height');
+ 
+ 	// Instead, we just return 1 x 1, as a non-zero value is required for laying out the editor correctly
+ 	return new Dimension(1, 1);
 }
 
 class SizeUtils {
diff --git a/src/vs/code/browser/workbench/workbench.ts b/src/vs/code/browser/workbench/workbench.ts
index f8875029a8a..3bdfd1bfa64 100644
--- a/src/vs/code/browser/workbench/workbench.ts
+++ b/src/vs/code/browser/workbench/workbench.ts
@@ -3,586 +3,41 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { isStandalone } from 'vs/base/browser/browser';
 import { mainWindow } from 'vs/base/browser/window';
-import { VSBuffer, decodeBase64, encodeBase64 } from 'vs/base/common/buffer';
-import { Emitter } from 'vs/base/common/event';
-import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
-import { parse } from 'vs/base/common/marshalling';
-import { Schemas } from 'vs/base/common/network';
-import { posix } from 'vs/base/common/path';
-import { isEqual } from 'vs/base/common/resources';
-import { ltrim } from 'vs/base/common/strings';
-import { URI, UriComponents } from 'vs/base/common/uri';
-import product from 'vs/platform/product/common/product';
-import { ISecretStorageProvider } from 'vs/platform/secrets/common/secrets';
-import { isFolderToOpen, isWorkspaceToOpen } from 'vs/platform/window/common/window';
+import { URI } from 'vs/base/common/uri';
 import type { IWorkbenchConstructionOptions, IWorkspace, IWorkspaceProvider } from 'vs/workbench/browser/web.api';
-import { AuthenticationSessionInfo } from 'vs/workbench/services/authentication/browser/authenticationService';
-import type { IURLCallbackProvider } from 'vs/workbench/services/url/browser/urlService';
 import { create } from 'vs/workbench/workbench.web.main';
 
-interface ISecretStorageCrypto {
-	seal(data: string): Promise<string>;
-	unseal(data: string): Promise<string>;
-}
+(async function () {
+	// create workbench
+	const result = await fetch('/vscode/product.json')
+	const loadedConfig: IWorkbenchConstructionOptions = await result.json()
 
-class TransparentCrypto implements ISecretStorageCrypto {
-	async seal(data: string): Promise<string> {
-		return data;
-	}
-
-	async unseal(data: string): Promise<string> {
-		return data;
-	}
-}
-
-const enum AESConstants {
-	ALGORITHM = 'AES-GCM',
-	KEY_LENGTH = 256,
-	IV_LENGTH = 12,
-}
-
-class ServerKeyedAESCrypto implements ISecretStorageCrypto {
-	private _serverKey: Uint8Array | undefined;
-
-	/** Gets whether the algorithm is supported; requires a secure context */
-	public static supported() {
-		return !!crypto.subtle;
-	}
-
-	constructor(private readonly authEndpoint: string) { }
-
-	async seal(data: string): Promise<string> {
-		// Get a new key and IV on every change, to avoid the risk of reusing the same key and IV pair with AES-GCM
-		// (see also: https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams#properties)
-		const iv = mainWindow.crypto.getRandomValues(new Uint8Array(AESConstants.IV_LENGTH));
-		// crypto.getRandomValues isn't a good-enough PRNG to generate crypto keys, so we need to use crypto.subtle.generateKey and export the key instead
-		const clientKeyObj = await mainWindow.crypto.subtle.generateKey(
-			{ name: AESConstants.ALGORITHM as const, length: AESConstants.KEY_LENGTH as const },
-			true,
-			['encrypt', 'decrypt']
-		);
-
-		const clientKey = new Uint8Array(await mainWindow.crypto.subtle.exportKey('raw', clientKeyObj));
-		const key = await this.getKey(clientKey);
-		const dataUint8Array = new TextEncoder().encode(data);
-		const cipherText: ArrayBuffer = await mainWindow.crypto.subtle.encrypt(
-			{ name: AESConstants.ALGORITHM as const, iv },
-			key,
-			dataUint8Array
-		);
-
-		// Base64 encode the result and store the ciphertext, the key, and the IV in localStorage
-		// Note that the clientKey and IV don't need to be secret
-		const result = new Uint8Array([...clientKey, ...iv, ...new Uint8Array(cipherText)]);
-		return encodeBase64(VSBuffer.wrap(result));
-	}
-
-	async unseal(data: string): Promise<string> {
-		// encrypted should contain, in order: the key (32-byte), the IV for AES-GCM (12-byte) and the ciphertext (which has the GCM auth tag at the end)
-		// Minimum length must be 44 (key+IV length) + 16 bytes (1 block encrypted with AES - regardless of key size)
-		const dataUint8Array = decodeBase64(data);
-
-		if (dataUint8Array.byteLength < 60) {
-			throw Error('Invalid length for the value for credentials.crypto');
-		}
-
-		const keyLength = AESConstants.KEY_LENGTH / 8;
-		const clientKey = dataUint8Array.slice(0, keyLength);
-		const iv = dataUint8Array.slice(keyLength, keyLength + AESConstants.IV_LENGTH);
-		const cipherText = dataUint8Array.slice(keyLength + AESConstants.IV_LENGTH);
-
-		// Do the decryption and parse the result as JSON
-		const key = await this.getKey(clientKey.buffer);
-		const decrypted = await mainWindow.crypto.subtle.decrypt(
-			{ name: AESConstants.ALGORITHM as const, iv: iv.buffer },
-			key,
-			cipherText.buffer
-		);
-
-		return new TextDecoder().decode(new Uint8Array(decrypted));
-	}
-
-	/**
-	 * Given a clientKey, returns the CryptoKey object that is used to encrypt/decrypt the data.
-	 * The actual key is (clientKey XOR serverKey)
-	 */
-	private async getKey(clientKey: Uint8Array): Promise<CryptoKey> {
-		if (!clientKey || clientKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
-			throw Error('Invalid length for clientKey');
-		}
-
-		const serverKey = await this.getServerKeyPart();
-		const keyData = new Uint8Array(AESConstants.KEY_LENGTH / 8);
-
-		for (let i = 0; i < keyData.byteLength; i++) {
-			keyData[i] = clientKey[i]! ^ serverKey[i]!;
-		}
-
-		return mainWindow.crypto.subtle.importKey(
-			'raw',
-			keyData,
-			{
-				name: AESConstants.ALGORITHM as const,
-				length: AESConstants.KEY_LENGTH as const,
-			},
-			true,
-			['encrypt', 'decrypt']
-		);
-	}
-
-	private async getServerKeyPart(): Promise<Uint8Array> {
-		if (this._serverKey) {
-			return this._serverKey;
-		}
-
-		let attempt = 0;
-		let lastError: unknown | undefined;
-
-		while (attempt <= 3) {
-			try {
-				const res = await fetch(this.authEndpoint, { credentials: 'include', method: 'POST' });
-				if (!res.ok) {
-					throw new Error(res.statusText);
-				}
-				const serverKey = new Uint8Array(await await res.arrayBuffer());
-				if (serverKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
-					throw Error(`The key retrieved by the server is not ${AESConstants.KEY_LENGTH} bit long.`);
-				}
-				this._serverKey = serverKey;
-				return this._serverKey;
-			} catch (e) {
-				lastError = e;
-				attempt++;
-
-				// exponential backoff
-				await new Promise(resolve => setTimeout(resolve, attempt * attempt * 100));
-			}
-		}
-
-		throw lastError;
-	}
-}
-
-export class LocalStorageSecretStorageProvider implements ISecretStorageProvider {
-	private readonly _storageKey = 'secrets.provider';
-
-	private _secretsPromise: Promise<Record<string, string>> = this.load();
-
-	type: 'in-memory' | 'persisted' | 'unknown' = 'persisted';
-
-	constructor(
-		private readonly crypto: ISecretStorageCrypto,
-	) { }
-
-	private async load(): Promise<Record<string, string>> {
-		const record = this.loadAuthSessionFromElement();
-		// Get the secrets from localStorage
-		const encrypted = localStorage.getItem(this._storageKey);
-		if (encrypted) {
-			try {
-				const decrypted = JSON.parse(await this.crypto.unseal(encrypted));
-				return { ...record, ...decrypted };
-			} catch (err) {
-				// TODO: send telemetry
-				console.error('Failed to decrypt secrets from localStorage', err);
-				localStorage.removeItem(this._storageKey);
-			}
-		}
-
-		return record;
-	}
-
-	private loadAuthSessionFromElement(): Record<string, string> {
-		let authSessionInfo: (AuthenticationSessionInfo & { scopes: string[][] }) | undefined;
-		const authSessionElement = mainWindow.document.getElementById('vscode-workbench-auth-session');
-		const authSessionElementAttribute = authSessionElement ? authSessionElement.getAttribute('data-settings') : undefined;
-		if (authSessionElementAttribute) {
-			try {
-				authSessionInfo = JSON.parse(authSessionElementAttribute);
-			} catch (error) { /* Invalid session is passed. Ignore. */ }
-		}
-
-		if (!authSessionInfo) {
-			return {};
-		}
-
-		const record: Record<string, string> = {};
-
-		// Settings Sync Entry
-		record[`${product.urlProtocol}.loginAccount`] = JSON.stringify(authSessionInfo);
-
-		// Auth extension Entry
-		if (authSessionInfo.providerId !== 'github') {
-			console.error(`Unexpected auth provider: ${authSessionInfo.providerId}. Expected 'github'.`);
-			return record;
-		}
-
-		const authAccount = JSON.stringify({ extensionId: 'vscode.github-authentication', key: 'github.auth' });
-		record[authAccount] = JSON.stringify(authSessionInfo.scopes.map(scopes => ({
-			id: authSessionInfo.id,
-			scopes,
-			accessToken: authSessionInfo.accessToken
-		})));
-
-		return record;
-	}
-
-	async get(key: string): Promise<string | undefined> {
-		const secrets = await this._secretsPromise;
-		return secrets[key];
-	}
-	async set(key: string, value: string): Promise<void> {
-		const secrets = await this._secretsPromise;
-		secrets[key] = value;
-		this._secretsPromise = Promise.resolve(secrets);
-		this.save();
-	}
-	async delete(key: string): Promise<void> {
-		const secrets = await this._secretsPromise;
-		delete secrets[key];
-		this._secretsPromise = Promise.resolve(secrets);
-		this.save();
-	}
-
-	private async save(): Promise<void> {
-		try {
-			const encrypted = await this.crypto.seal(JSON.stringify(await this._secretsPromise));
-			localStorage.setItem(this._storageKey, encrypted);
-		} catch (err) {
-			console.error(err);
-		}
-	}
-}
-
-
-class LocalStorageURLCallbackProvider extends Disposable implements IURLCallbackProvider {
-
-	private static REQUEST_ID = 0;
-
-	private static QUERY_KEYS: ('scheme' | 'authority' | 'path' | 'query' | 'fragment')[] = [
-		'scheme',
-		'authority',
-		'path',
-		'query',
-		'fragment'
-	];
-
-	private readonly _onCallback = this._register(new Emitter<URI>());
-	readonly onCallback = this._onCallback.event;
-
-	private pendingCallbacks = new Set<number>();
-	private lastTimeChecked = Date.now();
-	private checkCallbacksTimeout: unknown | undefined = undefined;
-	private onDidChangeLocalStorageDisposable: IDisposable | undefined;
-
-	constructor(private readonly _callbackRoute: string) {
-		super();
-	}
-
-	create(options: Partial<UriComponents> = {}): URI {
-		const id = ++LocalStorageURLCallbackProvider.REQUEST_ID;
-		const queryParams: string[] = [`vscode-reqid=${id}`];
-
-		for (const key of LocalStorageURLCallbackProvider.QUERY_KEYS) {
-			const value = options[key];
-
-			if (value) {
-				queryParams.push(`vscode-${key}=${encodeURIComponent(value)}`);
-			}
-		}
-
-		// TODO@joao remove eventually
-		// https://github.com/microsoft/vscode-dev/issues/62
-		// https://github.com/microsoft/vscode/blob/159479eb5ae451a66b5dac3c12d564f32f454796/extensions/github-authentication/src/githubServer.ts#L50-L50
-		if (!(options.authority === 'vscode.github-authentication' && options.path === '/dummy')) {
-			const key = `vscode-web.url-callbacks[${id}]`;
-			localStorage.removeItem(key);
-
-			this.pendingCallbacks.add(id);
-			this.startListening();
-		}
-
-		return URI.parse(mainWindow.location.href).with({ path: this._callbackRoute, query: queryParams.join('&') });
-	}
-
-	private startListening(): void {
-		if (this.onDidChangeLocalStorageDisposable) {
-			return;
-		}
-
-		const fn = () => this.onDidChangeLocalStorage();
-		mainWindow.addEventListener('storage', fn);
-		this.onDidChangeLocalStorageDisposable = { dispose: () => mainWindow.removeEventListener('storage', fn) };
-	}
-
-	private stopListening(): void {
-		this.onDidChangeLocalStorageDisposable?.dispose();
-		this.onDidChangeLocalStorageDisposable = undefined;
-	}
-
-	// this fires every time local storage changes, but we
-	// don't want to check more often than once a second
-	private async onDidChangeLocalStorage(): Promise<void> {
-		const ellapsed = Date.now() - this.lastTimeChecked;
-
-		if (ellapsed > 1000) {
-			this.checkCallbacks();
-		} else if (this.checkCallbacksTimeout === undefined) {
-			this.checkCallbacksTimeout = setTimeout(() => {
-				this.checkCallbacksTimeout = undefined;
-				this.checkCallbacks();
-			}, 1000 - ellapsed);
-		}
-	}
-
-	private checkCallbacks(): void {
-		let pendingCallbacks: Set<number> | undefined;
-
-		for (const id of this.pendingCallbacks) {
-			const key = `vscode-web.url-callbacks[${id}]`;
-			const result = localStorage.getItem(key);
-
-			if (result !== null) {
-				try {
-					this._onCallback.fire(URI.revive(JSON.parse(result)));
-				} catch (error) {
-					console.error(error);
-				}
-
-				pendingCallbacks = pendingCallbacks ?? new Set(this.pendingCallbacks);
-				pendingCallbacks.delete(id);
-				localStorage.removeItem(key);
-			}
-		}
-
-		if (pendingCallbacks) {
-			this.pendingCallbacks = pendingCallbacks;
-
-			if (this.pendingCallbacks.size === 0) {
-				this.stopListening();
-			}
-		}
-
-		this.lastTimeChecked = Date.now();
-	}
-}
-
-class WorkspaceProvider implements IWorkspaceProvider {
-
-	private static QUERY_PARAM_EMPTY_WINDOW = 'ew';
-	private static QUERY_PARAM_FOLDER = 'folder';
-	private static QUERY_PARAM_WORKSPACE = 'workspace';
-
-	private static QUERY_PARAM_PAYLOAD = 'payload';
-
-	static create(config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents }) {
-		let foundWorkspace = false;
-		let workspace: IWorkspace;
-		let payload = Object.create(null);
-
-		const query = new URL(document.location.href).searchParams;
-		query.forEach((value, key) => {
-			switch (key) {
-
-				// Folder
-				case WorkspaceProvider.QUERY_PARAM_FOLDER:
-					if (config.remoteAuthority && value.startsWith(posix.sep)) {
-						// when connected to a remote and having a value
-						// that is a path (begins with a `/`), assume this
-						// is a vscode-remote resource as simplified URL.
-						workspace = { folderUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
-					} else {
-						workspace = { folderUri: URI.parse(value) };
-					}
-					foundWorkspace = true;
-					break;
-
-				// Workspace
-				case WorkspaceProvider.QUERY_PARAM_WORKSPACE:
-					if (config.remoteAuthority && value.startsWith(posix.sep)) {
-						// when connected to a remote and having a value
-						// that is a path (begins with a `/`), assume this
-						// is a vscode-remote resource as simplified URL.
-						workspace = { workspaceUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
-					} else {
-						workspace = { workspaceUri: URI.parse(value) };
-					}
-					foundWorkspace = true;
-					break;
-
-				// Empty
-				case WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:
-					workspace = undefined;
-					foundWorkspace = true;
-					break;
-
-				// Payload
-				case WorkspaceProvider.QUERY_PARAM_PAYLOAD:
-					try {
-						payload = parse(value); // use marshalling#parse() to revive potential URIs
-					} catch (error) {
-						console.error(error); // possible invalid JSON
-					}
-					break;
-			}
-		});
-
-		// If no workspace is provided through the URL, check for config
-		// attribute from server
-		if (!foundWorkspace) {
-			if (config.folderUri) {
-				workspace = { folderUri: URI.revive(config.folderUri) };
-			} else if (config.workspaceUri) {
-				workspace = { workspaceUri: URI.revive(config.workspaceUri) };
-			}
-		}
-
-		return new WorkspaceProvider(workspace, payload, config);
-	}
-
-	readonly trusted = true;
+	// Inject project specific utopia config into the product.json
+	const urlParams = new URLSearchParams(window.location.search)
+	const vsCodeSessionID = urlParams.get('vs_code_session_id')!
 
-	private constructor(
-		readonly workspace: IWorkspace,
-		readonly payload: object,
-		private readonly config: IWorkbenchConstructionOptions
-	) {
-	}
-
-	async open(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): Promise<boolean> {
-		if (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {
-			return true; // return early if workspace and environment is not changing and we are reusing window
-		}
+	// Use this instance as the webview provider rather than hitting MS servers
+	const webviewEndpoint = `${window.location.origin}/vscode/vscode/vs/workbench/contrib/webview/browser/pre`
 
-		const targetHref = this.createTargetUrl(workspace, options);
-		if (targetHref) {
-			if (options?.reuse) {
-				mainWindow.location.href = targetHref;
-				return true;
-			} else {
-				let result;
-				if (isStandalone()) {
-					result = mainWindow.open(targetHref, '_blank', 'toolbar=no'); // ensures to open another 'standalone' window!
-				} else {
-					result = mainWindow.open(targetHref);
-				}
-
-				return !!result;
-			}
-		}
-		return false;
+	let config = {
+		...loadedConfig,
+		webviewEndpoint: webviewEndpoint,
+		editSessionId: vsCodeSessionID
 	}
 
-	private createTargetUrl(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): string | undefined {
-
-		// Empty
-		let targetHref: string | undefined = undefined;
-		if (!workspace) {
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;
-		}
-
-		// Folder
-		else if (isFolderToOpen(workspace)) {
-			const queryParamFolder = this.encodeWorkspacePath(workspace.folderUri);
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${queryParamFolder}`;
-		}
-
-		// Workspace
-		else if (isWorkspaceToOpen(workspace)) {
-			const queryParamWorkspace = this.encodeWorkspacePath(workspace.workspaceUri);
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${queryParamWorkspace}`;
-		}
-
-		// Append payload if any
-		if (options?.payload) {
-			targetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;
-		}
-
-		return targetHref;
+	const workspace = {
+		folderUri: URI.parse(`${vsCodeSessionID}:/`)
 	}
 
-	private encodeWorkspacePath(uri: URI): string {
-		if (this.config.remoteAuthority && uri.scheme === Schemas.vscodeRemote) {
-
-			// when connected to a remote and having a folder
-			// or workspace for that remote, only use the path
-			// as query value to form shorter, nicer URLs.
-			// however, we still need to `encodeURIComponent`
-			// to ensure to preserve special characters, such
-			// as `+` in the path.
-
-			return encodeURIComponent(`${posix.sep}${ltrim(uri.path, posix.sep)}`).replaceAll('%2F', '/');
+	if (workspace) {
+		const workspaceProvider: IWorkspaceProvider = { 
+			workspace,
+			open: async (_workspace: IWorkspace, _options?: { reuse?: boolean, payload?: object }) => true,
+			trusted: true 
 		}
-
-		return encodeURIComponent(uri.toString(true));
-	}
-
-	private isSame(workspaceA: IWorkspace, workspaceB: IWorkspace): boolean {
-		if (!workspaceA || !workspaceB) {
-			return workspaceA === workspaceB; // both empty
-		}
-
-		if (isFolderToOpen(workspaceA) && isFolderToOpen(workspaceB)) {
-			return isEqual(workspaceA.folderUri, workspaceB.folderUri); // same workspace
-		}
-
-		if (isWorkspaceToOpen(workspaceA) && isWorkspaceToOpen(workspaceB)) {
-			return isEqual(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace
-		}
-
-		return false;
-	}
-
-	hasRemote(): boolean {
-		if (this.workspace) {
-			if (isFolderToOpen(this.workspace)) {
-				return this.workspace.folderUri.scheme === Schemas.vscodeRemote;
-			}
-
-			if (isWorkspaceToOpen(this.workspace)) {
-				return this.workspace.workspaceUri.scheme === Schemas.vscodeRemote;
-			}
-		}
-
-		return true;
-	}
-}
-
-function readCookie(name: string): string | undefined {
-	const cookies = document.cookie.split('; ');
-	for (const cookie of cookies) {
-		if (cookie.startsWith(name + '=')) {
-			return cookie.substring(name.length + 1);
-		}
-	}
-
-	return undefined;
-}
-
-(function () {
-
-	// Find config by checking for DOM
-	const configElement = mainWindow.document.getElementById('vscode-workbench-web-configuration');
-	const configElementAttribute = configElement ? configElement.getAttribute('data-settings') : undefined;
-	if (!configElement || !configElementAttribute) {
-		throw new Error('Missing web configuration element');
+		config = { ...config, workspaceProvider }
 	}
-	const config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents; callbackRoute: string } = JSON.parse(configElementAttribute);
-	const secretStorageKeyPath = readCookie('vscode-secret-key-path');
-	const secretStorageCrypto = secretStorageKeyPath && ServerKeyedAESCrypto.supported()
-		? new ServerKeyedAESCrypto(secretStorageKeyPath) : new TransparentCrypto();
 
-	// Create workbench
-	create(mainWindow.document.body, {
-		...config,
-		windowIndicator: config.windowIndicator ?? { label: '$(remote)', tooltip: `${product.nameShort} Web` },
-		settingsSyncOptions: config.settingsSyncOptions ? { enabled: config.settingsSyncOptions.enabled, } : undefined,
-		workspaceProvider: WorkspaceProvider.create(config),
-		urlCallbackProvider: new LocalStorageURLCallbackProvider(config.callbackRoute),
-		secretStorageProvider: config.remoteAuthority && !secretStorageKeyPath
-			? undefined /* with a remote without embedder-preferred storage, store on the remote */
-			: new LocalStorageSecretStorageProvider(secretStorageCrypto),
-	});
+	create(mainWindow.document.body, config)
 })();
diff --git a/src/vs/editor/common/config/editorOptions.ts b/src/vs/editor/common/config/editorOptions.ts
index 294e7030695..46730d6d518 100644
--- a/src/vs/editor/common/config/editorOptions.ts
+++ b/src/vs/editor/common/config/editorOptions.ts
@@ -3093,7 +3093,7 @@ class EditorMinimap extends BaseEditorOption<EditorOption.minimap, IEditorMinima
 
 	constructor() {
 		const defaults: EditorMinimapOptions = {
-			enabled: true,
+			enabled: false,
 			size: 'proportional',
 			side: 'right',
 			showSlider: 'mouseover',
diff --git a/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts b/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
index 81db8b47267..fc76d98a5d3 100644
--- a/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
+++ b/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
@@ -26,13 +26,7 @@ flakySuite('Native Modules (all platforms)', () => {
 		assert.ok(typeof result === 'boolean', testErrorMessage('native-is-elevated'));
 	});
 
-	test('native-keymap', async () => {
-		const keyMap = await import('native-keymap');
-		assert.ok(typeof keyMap.getCurrentKeyboardLayout === 'function', testErrorMessage('native-keymap'));
-
-		const result = keyMap.getCurrentKeyboardLayout();
-		assert.ok(result, testErrorMessage('native-keymap'));
-	});
+	// I removed everything involving native-keymap as that was causing issues with the build involving Electron (which we obviously don't care about)
 
 	test('native-watchdog', async () => {
 		const watchDog = await import('native-watchdog');
diff --git a/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts b/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
index 1d17e4c709e..00109563f5c 100644
--- a/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
+++ b/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
@@ -3,8 +3,6 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import type * as nativeKeymap from 'native-keymap';
-import * as platform from 'vs/base/common/platform';
 import { Emitter } from 'vs/base/common/event';
 import { Disposable } from 'vs/base/common/lifecycle';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
@@ -45,29 +43,10 @@ export class KeyboardLayoutMainService extends Disposable implements INativeKeyb
 		return this._initPromise;
 	}
 
-	private async _doInitialize(): Promise<void> {
-		const nativeKeymapMod = await import('native-keymap');
-
-		this._keyboardLayoutData = readKeyboardLayoutData(nativeKeymapMod);
-		if (!platform.isCI) {
-			// See https://github.com/microsoft/vscode/issues/152840
-			// Do not register the keyboard layout change listener in CI because it doesn't work
-			// on the build machines and it just adds noise to the build logs.
-			nativeKeymapMod.onDidChangeKeyboardLayout(() => {
-				this._keyboardLayoutData = readKeyboardLayoutData(nativeKeymapMod);
-				this._onDidChangeKeyboardLayout.fire(this._keyboardLayoutData);
-			});
-		}
-	}
+	private async _doInitialize(): Promise<void> {}
 
 	public async getKeyboardLayoutData(): Promise<IKeyboardLayoutData> {
 		await this._initialize();
 		return this._keyboardLayoutData!;
 	}
 }
-
-function readKeyboardLayoutData(nativeKeymapMod: typeof nativeKeymap): IKeyboardLayoutData {
-	const keyboardMapping = nativeKeymapMod.getKeyMap();
-	const keyboardLayoutInfo = nativeKeymapMod.getCurrentKeyboardLayout();
-	return { keyboardMapping, keyboardLayoutInfo };
-}
diff --git a/src/vs/workbench/browser/layout.ts b/src/vs/workbench/browser/layout.ts
index b8232cb8490..0ce6a8e7002 100644
--- a/src/vs/workbench/browser/layout.ts
+++ b/src/vs/workbench/browser/layout.ts
@@ -1203,40 +1203,40 @@ export abstract class Layout extends Disposable implements IWorkbenchLayoutServi
 
 		if (this.initialized) {
 			switch (part) {
-				case Parts.TITLEBAR_PART:
-					return this.workbenchGrid.isViewVisible(this.titleBarPartView);
-				case Parts.SIDEBAR_PART:
-					return !this.stateModel.getRuntimeValue(LayoutStateKeys.SIDEBAR_HIDDEN);
-				case Parts.PANEL_PART:
-					return !this.stateModel.getRuntimeValue(LayoutStateKeys.PANEL_HIDDEN);
-				case Parts.AUXILIARYBAR_PART:
-					return !this.stateModel.getRuntimeValue(LayoutStateKeys.AUXILIARYBAR_HIDDEN);
-				case Parts.STATUSBAR_PART:
-					return !this.stateModel.getRuntimeValue(LayoutStateKeys.STATUSBAR_HIDDEN);
-				case Parts.ACTIVITYBAR_PART:
-					return !this.stateModel.getRuntimeValue(LayoutStateKeys.ACTIVITYBAR_HIDDEN);
+				// case Parts.TITLEBAR_PART:
+				// 	return this.workbenchGrid.isViewVisible(this.titleBarPartView);
+				// case Parts.SIDEBAR_PART:
+				// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.SIDEBAR_HIDDEN);
+				// case Parts.PANEL_PART:
+				// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.PANEL_HIDDEN);
+				// case Parts.AUXILIARYBAR_PART:
+				// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.AUXILIARYBAR_HIDDEN);
+				// case Parts.STATUSBAR_PART:
+				// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.STATUSBAR_HIDDEN);
+				// case Parts.ACTIVITYBAR_PART:
+				// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.ACTIVITYBAR_HIDDEN);
 				case Parts.EDITOR_PART:
 					return !this.stateModel.getRuntimeValue(LayoutStateKeys.EDITOR_HIDDEN);
-				case Parts.BANNER_PART:
-					return this.workbenchGrid.isViewVisible(this.bannerPartView);
+				// case Parts.BANNER_PART:
+				// 	return this.workbenchGrid.isViewVisible(this.bannerPartView);
 				default:
 					return false; // any other part cannot be hidden
 			}
 		}
 
 		switch (part) {
-			case Parts.TITLEBAR_PART:
-				return shouldShowCustomTitleBar(this.configurationService, mainWindow, this.state.runtime.menuBar.toggled, this.isZenModeActive());
-			case Parts.SIDEBAR_PART:
-				return !this.stateModel.getRuntimeValue(LayoutStateKeys.SIDEBAR_HIDDEN);
-			case Parts.PANEL_PART:
-				return !this.stateModel.getRuntimeValue(LayoutStateKeys.PANEL_HIDDEN);
-			case Parts.AUXILIARYBAR_PART:
-				return !this.stateModel.getRuntimeValue(LayoutStateKeys.AUXILIARYBAR_HIDDEN);
-			case Parts.STATUSBAR_PART:
-				return !this.stateModel.getRuntimeValue(LayoutStateKeys.STATUSBAR_HIDDEN);
-			case Parts.ACTIVITYBAR_PART:
-				return !this.stateModel.getRuntimeValue(LayoutStateKeys.ACTIVITYBAR_HIDDEN);
+			// case Parts.TITLEBAR_PART:
+			// 	return shouldShowCustomTitleBar(this.configurationService, mainWindow, this.state.runtime.menuBar.toggled, this.isZenModeActive());
+			// case Parts.SIDEBAR_PART:
+			// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.SIDEBAR_HIDDEN);
+			// case Parts.PANEL_PART:
+			// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.PANEL_HIDDEN);
+			// case Parts.AUXILIARYBAR_PART:
+			// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.AUXILIARYBAR_HIDDEN);
+			// case Parts.STATUSBAR_PART:
+			// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.STATUSBAR_HIDDEN);
+			// case Parts.ACTIVITYBAR_PART:
+			// 	return !this.stateModel.getRuntimeValue(LayoutStateKeys.ACTIVITYBAR_HIDDEN);
 			case Parts.EDITOR_PART:
 				return !this.stateModel.getRuntimeValue(LayoutStateKeys.EDITOR_HIDDEN);
 			default:
@@ -1293,7 +1293,7 @@ export abstract class Layout extends Disposable implements IWorkbenchLayoutServi
 	}
 
 	private isZenModeActive(): boolean {
-		return this.stateModel.getRuntimeValue(LayoutStateKeys.ZEN_MODE_ACTIVE);
+		return true; // Always true to remove all of the other UI
 	}
 
 	private setZenModeActive(active: boolean) {
diff --git a/src/vs/workbench/browser/workbench.contribution.ts b/src/vs/workbench/browser/workbench.contribution.ts
index ae4d22c9eaa..e342fb223d8 100644
--- a/src/vs/workbench/browser/workbench.contribution.ts
+++ b/src/vs/workbench/browser/workbench.contribution.ts
@@ -784,12 +784,12 @@ const registry = Registry.as<IConfigurationRegistry>(ConfigurationExtensions.Con
 		'properties': {
 			'zenMode.fullScreen': {
 				'type': 'boolean',
-				'default': true,
+				'default': false,
 				'description': localize('zenMode.fullScreen', "Controls whether turning on Zen Mode also puts the workbench into full screen mode.")
 			},
 			'zenMode.centerLayout': {
 				'type': 'boolean',
-				'default': true,
+				'default': false,
 				'description': localize('zenMode.centerLayout', "Controls whether turning on Zen Mode also centers the layout.")
 			},
 			'zenMode.showTabs': {
@@ -815,7 +815,7 @@ const registry = Registry.as<IConfigurationRegistry>(ConfigurationExtensions.Con
 			},
 			'zenMode.hideLineNumbers': {
 				'type': 'boolean',
-				'default': true,
+				'default': false,
 				'description': localize('zenMode.hideLineNumbers', "Controls whether turning on Zen Mode also hides the editor line numbers.")
 			},
 			'zenMode.restore': {
diff --git a/src/vs/workbench/browser/workbench.ts b/src/vs/workbench/browser/workbench.ts
index b0688133537..4353093fd5b 100644
--- a/src/vs/workbench/browser/workbench.ts
+++ b/src/vs/workbench/browser/workbench.ts
@@ -50,6 +50,8 @@ import { AccessibilityProgressSignalScheduler } from 'vs/platform/accessibilityS
 import { setProgressAcccessibilitySignalScheduler } from 'vs/base/browser/ui/progressbar/progressAccessibilitySignal';
 import { AccessibleViewRegistry } from 'vs/platform/accessibility/browser/accessibleViewRegistry';
 import { NotificationAccessibleView } from 'vs/workbench/browser/parts/notifications/notificationAccessibleView';
+import { ICommandService } from '../../platform/commands/common/commands';
+import { isFromUtopiaToVSCodeMessage, messageListenersReady } from 'utopia-vscode-common';
 
 export interface IWorkbenchOptions {
 
@@ -193,6 +195,37 @@ export class Workbench extends Layout {
 				this.restore(lifecycleService);
 			});
 
+			// Chain off of the previous one to ensure the ordering of changes is maintained.
+			// FIXME Do we still need this?
+			let applyProjectChangesCoordinator: Promise<void> = Promise.resolve()
+
+			let intervalID: number | null = null
+
+			mainWindow.addEventListener('message', (messageEvent: MessageEvent) => {
+				const { data } = messageEvent;
+				if (isFromUtopiaToVSCodeMessage(data)) {
+					const commandService = this.serviceCollection.get(ICommandService);
+					if (commandService == null) {
+						console.error(`There is no command service`);
+					} else {
+						if (intervalID != null) {
+							window.clearInterval(intervalID)
+						}
+						applyProjectChangesCoordinator = applyProjectChangesCoordinator.then(async () => {
+							(commandService as ICommandService).executeCommand('utopia.toVSCodeMessage', data);
+						})
+					}
+				}
+			});
+
+			intervalID = window.setInterval(() => {
+				try {
+					window.top?.postMessage(messageListenersReady(), '*')
+				} catch (error) {
+					console.error('Error posting messageListenersReady', error)
+				}
+			}, 500)
+
 			return instantiationService;
 		} catch (error) {
 			onUnexpectedError(error);
diff --git a/src/vs/workbench/contrib/files/browser/fileCommands.ts b/src/vs/workbench/contrib/files/browser/fileCommands.ts
index 81bf68c3e0b..1075398b4b8 100644
--- a/src/vs/workbench/contrib/files/browser/fileCommands.ts
+++ b/src/vs/workbench/contrib/files/browser/fileCommands.ts
@@ -53,6 +53,7 @@ import { IFileDialogService } from 'vs/platform/dialogs/common/dialogs';
 import { RemoveRootFolderAction } from 'vs/workbench/browser/actions/workspaceActions';
 import { OpenEditorsView } from 'vs/workbench/contrib/files/browser/views/openEditorsView';
 import { ExplorerView } from 'vs/workbench/contrib/files/browser/views/explorerView';
+import { mainWindow } from '../../../../base/browser/window';
 
 export const openWindowCommand = (accessor: ServicesAccessor, toOpen: IWindowOpenable[], options?: IOpenWindowOptions) => {
 	if (Array.isArray(toOpen)) {
@@ -734,3 +735,43 @@ CommandsRegistry.registerCommand({
 		});
 	}
 });
+
+CommandsRegistry.registerCommand({
+	id: 'workbench.action.files.revertResource',
+	handler: async (accessor, resource: URI) => {
+		const notificationService = accessor.get(INotificationService);
+		const editorGroupService = accessor.get(IEditorGroupsService);
+		const editorService = accessor.get(IEditorService);
+
+		// Retrieve editors for resource
+		const resourceAsString = resource.toString()
+		const matchesTarget = (uri: URI | undefined) => uri != null && uri.toString() === resourceAsString
+		let editors: IEditorIdentifier[] = []
+		
+		editorGroupService.groups.forEach(editorGroup => {
+			editorGroup.editors.forEach(editor => {
+				if (matchesTarget(editor.resource)) {
+					editors.push({ groupId: editorGroup.id, editor: editor })
+				}
+			})
+		})
+
+		if (!editors || editors.length === 0) {
+			return; // nothing to revert
+		}
+
+		try {
+			await editorService.revert(editors.filter(({ editor }) => !editor.hasCapability(EditorInputCapabilities.Untitled) /* all except untitled */), { force: true });
+		} catch (error) {
+			notificationService.error(nls.localize('genericRevertError', "Failed to revert '{0}': {1}", editors.map(({ editor }) => editor.getName()).join(', '), toErrorMessage(error, false)));
+		}
+	}
+});
+
+
+CommandsRegistry.registerCommand({
+	id: 'utopia.toUtopiaMessage',
+	handler: async (_accessor, message: any) => {
+		mainWindow.top?.postMessage(message);
+	}
+});
\ No newline at end of file
diff --git a/src/vs/workbench/contrib/files/browser/files.contribution.ts b/src/vs/workbench/contrib/files/browser/files.contribution.ts
index d525ba5860c..56ae5cfbc70 100644
--- a/src/vs/workbench/contrib/files/browser/files.contribution.ts
+++ b/src/vs/workbench/contrib/files/browser/files.contribution.ts
@@ -267,7 +267,7 @@ configurationRegistry.registerConfiguration({
 				nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.onFocusChange' }, "An editor with changes is automatically saved when the editor loses focus."),
 				nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'files.autoSave.onWindowChange' }, "An editor with changes is automatically saved when the window loses focus.")
 			],
-			'default': isWeb ? AutoSaveConfiguration.AFTER_DELAY : AutoSaveConfiguration.OFF,
+			'default': AutoSaveConfiguration.OFF,
 			'markdownDescription': nls.localize({ comment: ['This is the description for a setting. Values surrounded by single quotes are not to be translated.'], key: 'autoSave' }, "Controls [auto save](https://code.visualstudio.com/docs/editor/codebasics#_save-auto-save) of editors that have unsaved changes.", AutoSaveConfiguration.OFF, AutoSaveConfiguration.AFTER_DELAY, AutoSaveConfiguration.ON_FOCUS_CHANGE, AutoSaveConfiguration.ON_WINDOW_CHANGE, AutoSaveConfiguration.AFTER_DELAY),
 			scope: ConfigurationScope.LANGUAGE_OVERRIDABLE
 		},
diff --git a/src/vs/workbench/services/extensionManagement/browser/builtinExtensionsScannerService.ts b/src/vs/workbench/services/extensionManagement/browser/builtinExtensionsScannerService.ts
index e1913359976..3834f2dde41 100644
--- a/src/vs/workbench/services/extensionManagement/browser/builtinExtensionsScannerService.ts
+++ b/src/vs/workbench/services/extensionManagement/browser/builtinExtensionsScannerService.ts
@@ -51,10 +51,11 @@ export class BuiltinExtensionsScannerService implements IBuiltinExtensionsScanne
 			if (builtinExtensionsServiceUrl) {
 				let bundledExtensions: IBundledExtension[] = [];
 
-				if (environmentService.isBuilt) {
-					// Built time configuration (do NOT modify)
-					bundledExtensions = [/*BUILD->INSERT_BUILTIN_EXTENSIONS*/];
-				} else {
+				// This code prevents us from slipping our extension into the list of built in extensions
+				// if (environmentService.isBuilt) {
+				// 	// Built time configuration (do NOT modify)
+				// 	bundledExtensions = [/*BUILD->INSERT_BUILTIN_EXTENSIONS*/];
+				// } else {
 					// Find builtin extensions by checking for DOM
 					const builtinExtensionsElement = mainWindow.document.getElementById('vscode-workbench-builtin-extensions');
 					const builtinExtensionsElementAttribute = builtinExtensionsElement ? builtinExtensionsElement.getAttribute('data-settings') : undefined;
@@ -63,7 +64,7 @@ export class BuiltinExtensionsScannerService implements IBuiltinExtensionsScanne
 							bundledExtensions = JSON.parse(builtinExtensionsElementAttribute);
 						} catch (error) { /* ignore error*/ }
 					}
-				}
+				// }
 
 				this.builtinExtensionsPromises = bundledExtensions.map(async e => {
 					const id = getGalleryExtensionId(e.packageJSON.publisher, e.packageJSON.name);
diff --git a/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.ts b/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.ts
index 0c8d2e27317..2d42580e17b 100644
--- a/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.ts
+++ b/src/vs/workbench/services/extensions/browser/webWorkerExtensionHost.ts
@@ -115,8 +115,13 @@ export class WebWorkerExtensionHost extends Disposable implements IExtensionHost
 			console.warn(`The web worker extension host is started in a same-origin iframe!`);
 		}
 
+		// We want to use the cdn for loading all assets, but if we create this iframe using the cdn
+		// path then the cross origin settings prevent it from calling postmessage on its parent
 		const relativeExtensionHostIframeSrc = FileAccess.asBrowserUri(iframeModulePath);
-		return `${relativeExtensionHostIframeSrc.toString(true)}${suffix}`;
+		const authority = relativeExtensionHostIframeSrc.authority;
+		const authorityWithoutCDN = authority.startsWith('cdn.') ? authority.slice(4) : authority;
+		const srcWithoutCDN = relativeExtensionHostIframeSrc.with({authority: authorityWithoutCDN});
+		return `${srcWithoutCDN.toString(true)}${suffix}`;
 	}
 
 	public async start(): Promise<IMessagePassingProtocol> {
diff --git a/src/vs/workbench/services/extensions/common/abstractExtensionService.ts b/src/vs/workbench/services/extensions/common/abstractExtensionService.ts
index 731a48bf5b0..b77097ce7c2 100644
--- a/src/vs/workbench/services/extensions/common/abstractExtensionService.ts
+++ b/src/vs/workbench/services/extensions/common/abstractExtensionService.ts
@@ -121,7 +121,7 @@ export abstract class AbstractExtensionService extends Disposable implements IEx
 		// help the file service to activate providers by activating extensions by file system event
 		this._register(this._fileService.onWillActivateFileSystemProvider(e => {
 			if (e.scheme !== Schemas.vscodeRemote) {
-				e.join(this.activateByEvent(`onFileSystem:${e.scheme}`));
+				e.join(this.activateByEvent(`onFileSystem:utopia`));
 			}
 		}));
 
diff --git a/yarn.lock b/yarn.lock
index 71aef4295fa..3cfe4dade65 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -6508,6 +6508,13 @@ levn@^0.4.1:
     prelude-ls "^1.2.1"
     type-check "~0.4.0"
 
+lie@3.1.1:
+  version "3.1.1"
+  resolved "https://registry.yarnpkg.com/lie/-/lie-3.1.1.tgz#9a436b2cc7746ca59de7a41fa469b3efb76bd87e"
+  integrity sha512-RiNhHysUjhrDQntfYSfY4MU24coXXdEOgw9WGcKHNeEwffDYbF//u87M1EWaMGzuFoSbqW0C9C6lEEhDOAswfw==
+  dependencies:
+    immediate "~3.0.5"
+
 lie@~3.3.0:
   version "3.3.0"
   resolved "https://registry.yarnpkg.com/lie/-/lie-3.3.0.tgz#dcf82dee545f46074daf200c7c1c5a08e0f40f6a"
@@ -6576,6 +6583,13 @@ loader-utils@^2.0.0:
     emojis-list "^3.0.0"
     json5 "^2.1.2"
 
+localforage@1.9.0:
+  version "1.9.0"
+  resolved "https://registry.yarnpkg.com/localforage/-/localforage-1.9.0.tgz#f3e4d32a8300b362b4634cc4e066d9d00d2f09d1"
+  integrity sha512-rR1oyNrKulpe+VM9cYmcFn6tsHuokyVHFaCM3+osEmxaHTbEk8oQu6eGDfS6DQLWi/N67XRmB8ECG37OES368g==
+  dependencies:
+    lie "3.1.1"
+
 locate-path@^3.0.0:
   version "3.0.0"
   resolved "https://registry.yarnpkg.com/locate-path/-/locate-path-3.0.0.tgz#dbec3b3ab759758071b58fe59fc41871af21400e"
@@ -7200,11 +7214,6 @@ native-is-elevated@0.7.0:
   resolved "https://registry.yarnpkg.com/native-is-elevated/-/native-is-elevated-0.7.0.tgz#77499639e232edad1886403969e2bf236294e7af"
   integrity sha512-tp8hUqK7vexBiyIWKMvmRxdG6kqUtO+3eay9iB0i16NYgvCqE5wMe1Y0guHilpkmRgvVXEWNW4et1+qqcwpLBA==
 
-native-keymap@^3.3.5:
-  version "3.3.5"
-  resolved "https://registry.yarnpkg.com/native-keymap/-/native-keymap-3.3.5.tgz#b1da65d32e42bf65e3ff9db05bed319927dc2b01"
-  integrity sha512-7XDOLPNX1FnUFC/cX3cioBz2M+dO212ai9DuwpfKFzkPu3xTmEzOm5xewOMLXE4V9YoRhNPxvq1H2YpPWDgSsg==
-
 native-watchdog@^1.4.1:
   version "1.4.2"
   resolved "https://registry.yarnpkg.com/native-watchdog/-/native-watchdog-1.4.2.tgz#cf9f913157ee992723aa372b6137293c663be9b7"
@@ -8287,6 +8296,11 @@ prelude-ls@~1.1.2:
   resolved "https://registry.yarnpkg.com/prelude-ls/-/prelude-ls-1.1.2.tgz#21932a549f5e52ffd9a827f570e04be62a97da54"
   integrity sha1-IZMqVJ9eUv/ZqCf1cOBL5iqX2lQ=
 
+prettier@2.8.8:
+  version "2.8.8"
+  resolved "https://registry.yarnpkg.com/prettier/-/prettier-2.8.8.tgz#e8c5d7e98a4305ffe3de2e1fc4aca1a71c28b1da"
+  integrity sha512-tdN8qQGvNjw4CHbY+XXk0JgCXn9QiF21a55rBe5LJAU+kDyC4WQn4+awm2Xfk2lQMk5fKup9XgzTZtGkjBdP9Q==
+
 pretty-hrtime@^1.0.0:
   version "1.0.3"
   resolved "https://registry.yarnpkg.com/pretty-hrtime/-/pretty-hrtime-1.0.3.tgz#b7e3ea42435a4c9b2759d99e0f201eb195802ee1"
@@ -10235,6 +10249,12 @@ util@^0.12.4:
     is-typed-array "^1.1.3"
     which-typed-array "^1.1.2"
 
+"utopia-vscode-common@file:../../utopia-vscode-common":
+  version "0.1.6"
+  dependencies:
+    localforage "1.9.0"
+    prettier "2.8.8"
+
 uuid@^8.3.0:
   version "8.3.2"
   resolved "https://registry.yarnpkg.com/uuid/-/uuid-8.3.2.tgz#80d5b5ced271bb9af6c445f21a1a04c606cefbe2"
