diff --git a/build/gulpfile.vscode.js b/build/gulpfile.vscode.js
index 6d3a369082..7ad3222305 100644
--- a/build/gulpfile.vscode.js
+++ b/build/gulpfile.vscode.js
@@ -35,11 +35,12 @@ const { compileExtensionsBuildTask } = require('./gulpfile.extensions');
 
 // Build
 const vscodeEntryPoints = _.flatten([
-	buildfile.entrypoint('vs/workbench/workbench.desktop.main'),
+	buildfile.entrypoint('vs/workbench/workbench.web.api'),
 	buildfile.base,
 	buildfile.workerExtensionHost,
 	buildfile.workerNotebook,
-	buildfile.workbenchDesktop,
+	buildfile.workbenchWeb,
+  buildfile.keyboardMaps,
 	buildfile.code
 ]);
 
@@ -157,8 +158,8 @@ function packageTask(platform, arch, sourceFolderName, destinationFolderName, op
 
 		const checksums = computeChecksums(out, [
 			'vs/base/parts/sandbox/electron-browser/preload.js',
-			'vs/workbench/workbench.desktop.main.js',
-			'vs/workbench/workbench.desktop.main.css',
+			'vs/workbench/workbench.web.api.js',
+			'vs/workbench/workbench.web.api.css',
 			'vs/workbench/services/extensions/node/extensionHostProcess.js',
 			'vs/code/electron-browser/workbench/workbench.html',
 			'vs/code/electron-browser/workbench/workbench.js'
diff --git a/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json b/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json
deleted file mode 100644
index 9e26dfeeb6..0000000000
--- a/extensions/css-language-features/server/test/linksTestFixtures/node_modules/foo/package.json
+++ /dev/null
@@ -1 +0,0 @@
-{}
\ No newline at end of file
diff --git a/package.json b/package.json
index 1352c4355d..660abf0bb7 100644
--- a/package.json
+++ b/package.json
@@ -66,6 +66,7 @@
     "graceful-fs": "4.2.3",
     "http-proxy-agent": "^2.1.0",
     "https-proxy-agent": "^2.2.3",
+    "browserfs": "1.4.3",
     "iconv-lite-umd": "0.6.8",
     "jschardet": "2.2.1",
     "keytar": "7.2.0",
diff --git a/resources/web/code-web.js b/resources/web/code-web.js
index f4e97df0c6..5957bc3a5d 100644
--- a/resources/web/code-web.js
+++ b/resources/web/code-web.js
@@ -351,7 +351,7 @@ async function handleExtension(req, res, parsedUrl) {
  * @param {import('http').ServerResponse} res
  */
 async function handleRoot(req, res) {
-	let folderUri = { scheme: 'memfs', path: `/sample-folder` };
+	let folderUri = { scheme: 'utopia', path: `/utopia-project` };
 
 	const match = req.url && req.url.match(/\?([^#]+)/);
 	if (match) {
diff --git a/src/vs/code/browser/workbench/editorOnly.ts b/src/vs/code/browser/workbench/editorOnly.ts
new file mode 100644
index 0000000000..70069c6f11
--- /dev/null
+++ b/src/vs/code/browser/workbench/editorOnly.ts
@@ -0,0 +1,95 @@
+import { getSingletonServiceDescriptors, registerSingleton } from 'vs/platform/instantiation/common/extensions';
+import { BrandedService, ServiceIdentifier } from 'vs/platform/instantiation/common/instantiation';
+import { SyncDescriptor } from 'vs/platform/instantiation/common/descriptors';
+
+const _registry = getSingletonServiceDescriptors()
+
+function replaceRegisteredSingleton<T, Services extends BrandedService[]>(id: ServiceIdentifier<T>, ctor: new (...services: Services) => T, supportsDelayedInstantiation?: boolean): void {
+	const index = _registry.findIndex(tuple => tuple[0] === id)
+	if (index > 0) {
+		_registry[index] = [id, new SyncDescriptor<T>(ctor as new (...args: any[]) => T, [], supportsDelayedInstantiation)]
+	} else {
+		registerSingleton(id, ctor)
+	}
+}
+
+// Replace services for the parts we don't want to use -
+// We have to import the original part first to ensure it isn't registered later
+import 'vs/workbench/browser/parts/panel/panelPart'
+import { PanelPart } from 'vs/workbench/browser/parts/dummies/panelPart';
+import { IPanelService } from 'vs/workbench/services/panel/common/panelService';
+replaceRegisteredSingleton(IPanelService, PanelPart);
+
+import 'vs/workbench/browser/parts/sidebar/sidebarPart'
+import { SidebarPart } from 'vs/workbench/browser/parts/dummies/sidebarPart';
+import { IViewletService } from 'vs/workbench/services/viewlet/browser/viewlet';
+replaceRegisteredSingleton(IViewletService, SidebarPart);
+
+import 'vs/workbench/browser/parts/activitybar/activitybarPart'
+import { ActivitybarPart } from 'vs/workbench/browser/parts/dummies/activitybarPart'
+import { IActivityBarService } from 'vs/workbench/services/activityBar/browser/activityBarService';
+replaceRegisteredSingleton(IActivityBarService, ActivitybarPart);
+
+import 'vs/workbench/browser/parts/titlebar/titlebarPart'
+import { TitlebarPart } from 'vs/workbench/browser/parts/dummies/titlebarPart'
+import { ITitleService } from 'vs/workbench/services/title/common/titleService'
+replaceRegisteredSingleton(ITitleService, TitlebarPart);
+
+import 'vs/workbench/browser/parts/statusbar/statusbarPart'
+import { StatusbarPart } from 'vs/workbench/browser/parts/dummies/statusbarPart'
+import { IStatusbarService } from 'vs/workbench/services/statusbar/common/statusbar';
+replaceRegisteredSingleton(IStatusbarService, StatusbarPart);
+
+// Start the workbench
+import 'vs/code/browser/workbench/workbench'
+
+// Communication between extension and parent window
+
+import * as BrowserFS from 'browserfs';
+import { FSModule } from 'browserfs/dist/node/core/FS'
+
+let fileSystem: FSModule
+
+new Promise<void>((resolve) => {
+	BrowserFS.getFileSystem({ fs: 'IndexedDB', options: { storeName: 'utopia' } }, (e, v) => {
+		if (e || v == undefined) {
+			console.error(`Failed to start BrowserFS at the boundary`)
+			throw e
+		}
+
+		BrowserFS.initialize(v)
+		fileSystem = BrowserFS.BFSRequire('fs')
+		resolve()
+	})
+})
+
+function writeFile(path: string, content: string) {
+	new Promise<void>((resolve, reject) => {
+		fileSystem.writeFile(path, content, (e) => {
+			if (e == null) {
+				resolve()
+			} else {
+				console.log(`Failed to write file`, e)
+				reject(e)
+			}
+		})
+	})
+}
+
+interface UtopiaFSMessage {
+	type: 'UtopiaFSMessage',
+	path: string,
+	contents: string,
+}
+
+function isUtopiaFSMessage(data: unknown): data is UtopiaFSMessage {
+	return data != null && typeof data === 'object' && !Array.isArray(data) && (data as UtopiaFSMessage).type === 'UtopiaFSMessage'
+}
+
+window.addEventListener('message', (e) => {
+	if (isUtopiaFSMessage(e.data)) {
+		const { path, contents } = e.data
+		console.log(`Writing file ${path} with data ${contents}`)
+		writeFile(path, contents)
+	}
+})
diff --git a/src/vs/code/browser/workbench/workbench-dev.html b/src/vs/code/browser/workbench/workbench-dev.html
index 2df6f81256..f1f6f025d5 100644
--- a/src/vs/code/browser/workbench/workbench-dev.html
+++ b/src/vs/code/browser/workbench/workbench-dev.html
@@ -50,6 +50,9 @@
 				'tas-client-umd': `${window.location.origin}/static/remote/web/node_modules/tas-client-umd/lib/tas-client-umd.js`,
 				'iconv-lite-umd': `${window.location.origin}/static/remote/web/node_modules/iconv-lite-umd/lib/iconv-lite-umd.js`,
 				'jschardet': `${window.location.origin}/static/remote/web/node_modules/jschardet/dist/jschardet.min.js`,
+				'browserfs': `${window.location.origin}/static/node_modules/browserfs/dist/browserfs.min.js`,
+				// 'browserfs/dist/node/core/file_flag': `${window.location.origin}/static/node_modules/browserfs/dist/node/core/file_flag.js`,
+				// 'browserfs/dist/node/core/file_flag': `${window.location.origin}/static/node_modules/browserfs/dist/browserfs.min.js`,
 			}
 		};
 	</script>
@@ -58,6 +61,6 @@
 		performance.mark('code/willLoadWorkbenchMain');
 	</script>
 	<script>
-		require(['vs/code/browser/workbench/workbench'], function() {});
+		require(['vs/code/browser/workbench/editorOnly'], function() {});
 	</script>
 </html>
diff --git a/src/vs/code/browser/workbench/workbench.ts b/src/vs/code/browser/workbench/workbench.ts
index 1ed7feec97..7811b014ba 100644
--- a/src/vs/code/browser/workbench/workbench.ts
+++ b/src/vs/code/browser/workbench/workbench.ts
@@ -1,532 +1,31 @@
-/*---------------------------------------------------------------------------------------------
- *  Copyright (c) Microsoft Corporation. All rights reserved.
- *  Licensed under the MIT License. See License.txt in the project root for license information.
- *--------------------------------------------------------------------------------------------*/
+import { create, IWorkbenchConstructionOptions, IWorkspaceProvider } from 'vs/workbench/workbench.web.api';
+import { URI, UriComponents} from 'vs/base/common/uri';
 
-import { IWorkbenchConstructionOptions, create, ICredentialsProvider, IURLCallbackProvider, IWorkspaceProvider, IWorkspace, IWindowIndicator, IHomeIndicator, IProductQualityChangeHandler, ISettingsSyncOptions } from 'vs/workbench/workbench.web.api';
-import { URI, UriComponents } from 'vs/base/common/uri';
-import { Event, Emitter } from 'vs/base/common/event';
-import { generateUuid } from 'vs/base/common/uuid';
-import { CancellationToken } from 'vs/base/common/cancellation';
-import { streamToBuffer } from 'vs/base/common/buffer';
-import { Disposable } from 'vs/base/common/lifecycle';
-import { request } from 'vs/base/parts/request/browser/request';
-import { isFolderToOpen, isWorkspaceToOpen } from 'vs/platform/windows/common/windows';
-import { isEqual } from 'vs/base/common/resources';
-import { isStandalone } from 'vs/base/browser/browser';
-import { localize } from 'vs/nls';
-import { Schemas } from 'vs/base/common/network';
-import product from 'vs/platform/product/common/product';
-import { parseLogLevel } from 'vs/platform/log/common/log';
+(async function () {
+	// create workbench
+	const result = await fetch('/vscode/product.json');
+	let config: IWorkbenchConstructionOptions & { folderUri?: UriComponents, workspaceUri?: UriComponents }  = await result.json();
 
-function doCreateUri(path: string, queryValues: Map<string, string>): URI {
-	let query: string | undefined = undefined;
 
-	if (queryValues) {
-		let index = 0;
-		queryValues.forEach((value, key) => {
-			if (!query) {
-				query = '';
-			}
-
-			const prefix = (index++ === 0) ? '' : '&';
-			query += `${prefix}${key}=${encodeURIComponent(value)}`;
-		});
-	}
-
-	return URI.parse(window.location.href).with({ path, query });
-}
-
-interface ICredential {
-	service: string;
-	account: string;
-	password: string;
-}
-
-class LocalStorageCredentialsProvider implements ICredentialsProvider {
-
-	static readonly CREDENTIALS_OPENED_KEY = 'credentials.provider';
-
-	private readonly authService: string | undefined;
-
-	constructor() {
-		let authSessionInfo: { readonly id: string, readonly accessToken: string, readonly providerId: string, readonly canSignOut?: boolean, readonly scopes: string[][] } | undefined;
-		const authSessionElement = document.getElementById('vscode-workbench-auth-session');
-		const authSessionElementAttribute = authSessionElement ? authSessionElement.getAttribute('data-settings') : undefined;
-		if (authSessionElementAttribute) {
-			try {
-				authSessionInfo = JSON.parse(authSessionElementAttribute);
-			} catch (error) { /* Invalid session is passed. Ignore. */ }
-		}
-
-		if (authSessionInfo) {
-			// Settings Sync Entry
-			this.setPassword(`${product.urlProtocol}.login`, 'account', JSON.stringify(authSessionInfo));
-
-			// Auth extension Entry
-			this.authService = `${product.urlProtocol}-${authSessionInfo.providerId}.login`;
-			this.setPassword(this.authService, 'account', JSON.stringify(authSessionInfo.scopes.map(scopes => ({
-				id: authSessionInfo!.id,
-				scopes,
-				accessToken: authSessionInfo!.accessToken
-			}))));
-		}
-	}
-
-	private _credentials: ICredential[] | undefined;
-	private get credentials(): ICredential[] {
-		if (!this._credentials) {
-			try {
-				const serializedCredentials = window.localStorage.getItem(LocalStorageCredentialsProvider.CREDENTIALS_OPENED_KEY);
-				if (serializedCredentials) {
-					this._credentials = JSON.parse(serializedCredentials);
-				}
-			} catch (error) {
-				// ignore
-			}
-
-			if (!Array.isArray(this._credentials)) {
-				this._credentials = [];
-			}
-		}
-
-		return this._credentials;
-	}
-
-	private save(): void {
-		window.localStorage.setItem(LocalStorageCredentialsProvider.CREDENTIALS_OPENED_KEY, JSON.stringify(this.credentials));
-	}
-
-	async getPassword(service: string, account: string): Promise<string | null> {
-		return this.doGetPassword(service, account);
-	}
-
-	private async doGetPassword(service: string, account?: string): Promise<string | null> {
-		for (const credential of this.credentials) {
-			if (credential.service === service) {
-				if (typeof account !== 'string' || account === credential.account) {
-					return credential.password;
-				}
-			}
-		}
-
-		return null;
-	}
-
-	async setPassword(service: string, account: string, password: string): Promise<void> {
-		this.doDeletePassword(service, account);
-
-		this.credentials.push({ service, account, password });
-
-		this.save();
-
-		try {
-			if (password && service === this.authService) {
-				const value = JSON.parse(password);
-				if (Array.isArray(value) && value.length === 0) {
-					await this.logout(service);
-				}
-			}
-		} catch (error) {
-			console.log(error);
-		}
-	}
-
-	async deletePassword(service: string, account: string): Promise<boolean> {
-		const result = await this.doDeletePassword(service, account);
-
-		if (result && service === this.authService) {
-			try {
-				await this.logout(service);
-			} catch (error) {
-				console.log(error);
-			}
-		}
-
-		return result;
-	}
-
-	private async doDeletePassword(service: string, account: string): Promise<boolean> {
-		let found = false;
-
-		this._credentials = this.credentials.filter(credential => {
-			if (credential.service === service && credential.account === account) {
-				found = true;
-
-				return false;
-			}
-
-			return true;
-		});
-
-		if (found) {
-			this.save();
-		}
-
-		return found;
-	}
-
-	async findPassword(service: string): Promise<string | null> {
-		return this.doGetPassword(service);
-	}
-
-	async findCredentials(service: string): Promise<Array<{ account: string, password: string }>> {
-		return this.credentials
-			.filter(credential => credential.service === service)
-			.map(({ account, password }) => ({ account, password }));
-	}
-
-	private async logout(service: string): Promise<void> {
-		const queryValues: Map<string, string> = new Map();
-		queryValues.set('logout', String(true));
-		queryValues.set('service', service);
-
-		await request({
-			url: doCreateUri('/auth/logout', queryValues).toString(true)
-		}, CancellationToken.None);
-	}
-}
-
-class PollingURLCallbackProvider extends Disposable implements IURLCallbackProvider {
-
-	static readonly FETCH_INTERVAL = 500; 			// fetch every 500ms
-	static readonly FETCH_TIMEOUT = 5 * 60 * 1000; 	// ...but stop after 5min
-
-	static readonly QUERY_KEYS = {
-		REQUEST_ID: 'vscode-requestId',
-		SCHEME: 'vscode-scheme',
-		AUTHORITY: 'vscode-authority',
-		PATH: 'vscode-path',
-		QUERY: 'vscode-query',
-		FRAGMENT: 'vscode-fragment'
-	};
-
-	private readonly _onCallback = this._register(new Emitter<URI>());
-	readonly onCallback = this._onCallback.event;
-
-	create(options?: Partial<UriComponents>): URI {
-		const queryValues: Map<string, string> = new Map();
-
-		const requestId = generateUuid();
-		queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.REQUEST_ID, requestId);
-
-		const { scheme, authority, path, query, fragment } = options ? options : { scheme: undefined, authority: undefined, path: undefined, query: undefined, fragment: undefined };
-
-		if (scheme) {
-			queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.SCHEME, scheme);
-		}
-
-		if (authority) {
-			queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.AUTHORITY, authority);
-		}
-
-		if (path) {
-			queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.PATH, path);
-		}
-
-		if (query) {
-			queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.QUERY, query);
-		}
-
-		if (fragment) {
-			queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.FRAGMENT, fragment);
-		}
-
-		// Start to poll on the callback being fired
-		this.periodicFetchCallback(requestId, Date.now());
-
-		return doCreateUri('/callback', queryValues);
-	}
-
-	private async periodicFetchCallback(requestId: string, startTime: number): Promise<void> {
-
-		// Ask server for callback results
-		const queryValues: Map<string, string> = new Map();
-		queryValues.set(PollingURLCallbackProvider.QUERY_KEYS.REQUEST_ID, requestId);
-
-		const result = await request({
-			url: doCreateUri('/fetch-callback', queryValues).toString(true)
-		}, CancellationToken.None);
-
-		// Check for callback results
-		const content = await streamToBuffer(result.stream);
-		if (content.byteLength > 0) {
-			try {
-				this._onCallback.fire(URI.revive(JSON.parse(content.toString())));
-			} catch (error) {
-				console.error(error);
-			}
-
-			return; // done
-		}
-
-		// Continue fetching unless we hit the timeout
-		if (Date.now() - startTime < PollingURLCallbackProvider.FETCH_TIMEOUT) {
-			setTimeout(() => this.periodicFetchCallback(requestId, startTime), PollingURLCallbackProvider.FETCH_INTERVAL);
-		}
-	}
-}
-
-class WorkspaceProvider implements IWorkspaceProvider {
-
-	static QUERY_PARAM_EMPTY_WINDOW = 'ew';
-	static QUERY_PARAM_FOLDER = 'folder';
-	static QUERY_PARAM_WORKSPACE = 'workspace';
-
-	static QUERY_PARAM_PAYLOAD = 'payload';
-
-	constructor(
-		public readonly workspace: IWorkspace,
-		public readonly payload: object
-	) { }
-
-	async open(workspace: IWorkspace, options?: { reuse?: boolean, payload?: object }): Promise<void> {
-		if (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {
-			return; // return early if workspace and environment is not changing and we are reusing window
-		}
-
-		const targetHref = this.createTargetUrl(workspace, options);
-		if (targetHref) {
-			if (options?.reuse) {
-				window.location.href = targetHref;
-			} else {
-				if (isStandalone) {
-					window.open(targetHref, '_blank', 'toolbar=no'); // ensures to open another 'standalone' window!
-				} else {
-					window.open(targetHref);
-				}
-			}
-		}
-	}
-
-	private createTargetUrl(workspace: IWorkspace, options?: { reuse?: boolean, payload?: object }): string | undefined {
-
-		// Empty
-		let targetHref: string | undefined = undefined;
-		if (!workspace) {
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;
-		}
-
-		// Folder
-		else if (isFolderToOpen(workspace)) {
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${encodeURIComponent(workspace.folderUri.toString())}`;
-		}
-
-		// Workspace
-		else if (isWorkspaceToOpen(workspace)) {
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${encodeURIComponent(workspace.workspaceUri.toString())}`;
-		}
-
-		// Append payload if any
-		if (options?.payload) {
-			targetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;
-		}
-
-		return targetHref;
-	}
-
-	private isSame(workspaceA: IWorkspace, workspaceB: IWorkspace): boolean {
-		if (!workspaceA || !workspaceB) {
-			return workspaceA === workspaceB; // both empty
-		}
-
-		if (isFolderToOpen(workspaceA) && isFolderToOpen(workspaceB)) {
-			return isEqual(workspaceA.folderUri, workspaceB.folderUri); // same workspace
-		}
-
-		if (isWorkspaceToOpen(workspaceA) && isWorkspaceToOpen(workspaceB)) {
-			return isEqual(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace
-		}
-
-		return false;
-	}
-
-	hasRemote(): boolean {
-		if (this.workspace) {
-			if (isFolderToOpen(this.workspace)) {
-				return this.workspace.folderUri.scheme === Schemas.vscodeRemote;
-			}
-
-			if (isWorkspaceToOpen(this.workspace)) {
-				return this.workspace.workspaceUri.scheme === Schemas.vscodeRemote;
-			}
-		}
-
-		return true;
-	}
-}
-
-class WindowIndicator implements IWindowIndicator {
-
-	readonly onDidChange = Event.None;
-
-	readonly label: string;
-	readonly tooltip: string;
-	readonly command: string | undefined;
-
-	constructor(workspace: IWorkspace) {
-		let repositoryOwner: string | undefined = undefined;
-		let repositoryName: string | undefined = undefined;
-
-		if (workspace) {
-			let uri: URI | undefined = undefined;
-			if (isFolderToOpen(workspace)) {
-				uri = workspace.folderUri;
-			} else if (isWorkspaceToOpen(workspace)) {
-				uri = workspace.workspaceUri;
-			}
-
-			if (uri?.scheme === 'github' || uri?.scheme === 'codespace') {
-				[repositoryOwner, repositoryName] = uri.authority.split('+');
-			}
-		}
-
-		// Repo
-		if (repositoryName && repositoryOwner) {
-			this.label = localize('playgroundLabelRepository', "$(remote) VS Code Web Playground: {0}/{1}", repositoryOwner, repositoryName);
-			this.tooltip = localize('playgroundRepositoryTooltip', "VS Code Web Playground: {0}/{1}", repositoryOwner, repositoryName);
-		}
-
-		// No Repo
-		else {
-			this.label = localize('playgroundLabel', "$(remote) VS Code Web Playground");
-			this.tooltip = localize('playgroundTooltip', "VS Code Web Playground");
-		}
-	}
-}
-
-(function () {
-
-	// Find config by checking for DOM
-	const configElement = document.getElementById('vscode-workbench-web-configuration');
-	const configElementAttribute = configElement ? configElement.getAttribute('data-settings') : undefined;
-	if (!configElement || !configElementAttribute) {
-		throw new Error('Missing web configuration element');
-	}
-
-	const config: IWorkbenchConstructionOptions & { folderUri?: UriComponents, workspaceUri?: UriComponents } = JSON.parse(configElementAttribute);
-
-	// Revive static extension locations
 	if (Array.isArray(config.staticExtensions)) {
 		config.staticExtensions.forEach(extension => {
 			extension.extensionLocation = URI.revive(extension.extensionLocation);
 		});
 	}
 
-	// Find workspace to open and payload
-	let foundWorkspace = false;
-	let workspace: IWorkspace;
-	let payload = Object.create(null);
-	let logLevel: string | undefined = undefined;
-
-	const query = new URL(document.location.href).searchParams;
-	query.forEach((value, key) => {
-		switch (key) {
-
-			// Folder
-			case WorkspaceProvider.QUERY_PARAM_FOLDER:
-				workspace = { folderUri: URI.parse(value) };
-				foundWorkspace = true;
-				break;
-
-			// Workspace
-			case WorkspaceProvider.QUERY_PARAM_WORKSPACE:
-				workspace = { workspaceUri: URI.parse(value) };
-				foundWorkspace = true;
-				break;
-
-			// Empty
-			case WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:
-				workspace = undefined;
-				foundWorkspace = true;
-				break;
-
-			// Payload
-			case WorkspaceProvider.QUERY_PARAM_PAYLOAD:
-				try {
-					payload = JSON.parse(value);
-				} catch (error) {
-					console.error(error); // possible invalid JSON
-				}
-				break;
-
-			// Log level
-			case 'logLevel':
-				logLevel = value;
-				break;
-		}
-	});
-
-	// If no workspace is provided through the URL, check for config attribute from server
-	if (!foundWorkspace) {
-		if (config.folderUri) {
-			workspace = { folderUri: URI.revive(config.folderUri) };
-		} else if (config.workspaceUri) {
-			workspace = { workspaceUri: URI.revive(config.workspaceUri) };
-		} else {
-			workspace = undefined;
-		}
+	let workspace;
+	if (config.folderUri) {
+		workspace = { folderUri: URI.revive(config.folderUri) };
+	} else if (config.workspaceUri) {
+		workspace = { workspaceUri: URI.revive(config.workspaceUri) };
+	} else {
+		workspace = undefined;
 	}
 
-	// Workspace Provider
-	const workspaceProvider = new WorkspaceProvider(workspace, payload);
-
-	// Home Indicator
-	const homeIndicator: IHomeIndicator = {
-		href: 'https://github.com/microsoft/vscode',
-		icon: 'code',
-		title: localize('home', "Home")
-	};
-
-	// Window indicator (unless connected to a remote)
-	let windowIndicator: WindowIndicator | undefined = undefined;
-	if (!workspaceProvider.hasRemote()) {
-		windowIndicator = new WindowIndicator(workspace);
+	if(workspace){
+		const workspaceProvider: IWorkspaceProvider = { workspace, open: async () => {} }
+		config = { ...config, workspaceProvider };
 	}
 
-	// Product Quality Change Handler
-	const productQualityChangeHandler: IProductQualityChangeHandler = (quality) => {
-		let queryString = `quality=${quality}`;
-
-		// Save all other query params we might have
-		const query = new URL(document.location.href).searchParams;
-		query.forEach((value, key) => {
-			if (key !== 'quality') {
-				queryString += `&${key}=${value}`;
-			}
-		});
-
-		window.location.href = `${window.location.origin}?${queryString}`;
-	};
-
-	// settings sync options
-	const settingsSyncOptions: ISettingsSyncOptions | undefined = config.settingsSyncOptions ? {
-		enabled: config.settingsSyncOptions.enabled,
-		enablementHandler: (enablement) => {
-			let queryString = `settingsSync=${enablement ? 'true' : 'false'}`;
-
-			// Save all other query params we might have
-			const query = new URL(document.location.href).searchParams;
-			query.forEach((value, key) => {
-				if (key !== 'settingsSync') {
-					queryString += `&${key}=${value}`;
-				}
-			});
-
-			window.location.href = `${window.location.origin}?${queryString}`;
-		}
-	} : undefined;
-
-	// Finally create workbench
-	create(document.body, {
-		...config,
-		logLevel: logLevel ? parseLogLevel(logLevel) : undefined,
-		settingsSyncOptions,
-		homeIndicator,
-		windowIndicator,
-		productQualityChangeHandler,
-		workspaceProvider,
-		urlCallbackProvider: new PollingURLCallbackProvider(),
-		credentialsProvider: new LocalStorageCredentialsProvider()
-	});
+	create(document.body, config);
 })();
diff --git a/src/vs/workbench/browser/parts/dummies/activitybarPart.ts b/src/vs/workbench/browser/parts/dummies/activitybarPart.ts
new file mode 100644
index 0000000000..455a50bb45
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/activitybarPart.ts
@@ -0,0 +1,25 @@
+import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { DummyPart } from 'vs/workbench/browser/parts/dummies/dummyPart';
+import { IBadge } from 'vs/workbench/services/activity/common/activity';
+import { IActivityBarService } from 'vs/workbench/services/activityBar/browser/activityBarService';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+
+export class ActivitybarPart extends DummyPart implements IActivityBarService {
+	declare readonly _serviceBrand: undefined;
+
+	constructor(
+		@IThemeService themeService: IThemeService,
+		@IStorageService storageService: IStorageService,
+		@IWorkbenchLayoutService layoutService: IWorkbenchLayoutService) {
+		super(Parts.ACTIVITYBAR_PART, themeService, storageService, layoutService)
+
+		this.setVisible(false)
+	}
+
+	showActivity(viewletOrActionId: string, badge: IBadge, clazz?: string, priority?: number): IDisposable { return Disposable.None }
+	getPinnedViewContainerIds(): string[] { return [] }
+	getVisibleViewContainerIds(): string[] { return [] }
+	focusActivityBar(): void { }
+}
diff --git a/src/vs/workbench/browser/parts/dummies/dummyPart.ts b/src/vs/workbench/browser/parts/dummies/dummyPart.ts
new file mode 100644
index 0000000000..8bc3a355ed
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/dummyPart.ts
@@ -0,0 +1,39 @@
+import { Event } from 'vs/base/common/event';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { Part } from 'vs/workbench/browser/part';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+
+export abstract class DummyPart extends Part {
+	constructor(
+		private part: Parts,
+		themeService: IThemeService,
+		storageService: IStorageService,
+		layoutService: IWorkbenchLayoutService
+	) {
+		super(part, {}, themeService, storageService, layoutService)
+	}
+
+	create(parent: HTMLElement): void {
+		this.element = parent
+	}
+
+	setVisible(_: boolean) {
+		super.setVisible(false)
+	}
+
+	minimumWidth: number = 0
+	maximumWidth: number = Number.POSITIVE_INFINITY;
+	minimumHeight: number = 0
+	maximumHeight: number = Number.POSITIVE_INFINITY;
+	toJSON(): object {
+		return {
+			type: this.part
+		}
+	}
+
+	onDidOpenEvent<T>(): Event<T> {
+		this.setVisible(false);
+		return Event.None
+	}
+}
diff --git a/src/vs/workbench/browser/parts/dummies/panelPart.ts b/src/vs/workbench/browser/parts/dummies/panelPart.ts
new file mode 100644
index 0000000000..7615e89b43
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/panelPart.ts
@@ -0,0 +1,45 @@
+import { Event } from 'vs/base/common/event';
+import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
+import { IProgressIndicator } from 'vs/platform/progress/common/progress';
+import { IPanel } from 'vs/workbench/common/panel';
+import { IBadge } from 'vs/workbench/services/activity/common/activity';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+import { IPanelIdentifier, IPanelService } from 'vs/workbench/services/panel/common/panelService';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { DummyPart } from 'vs/workbench/browser/parts/dummies/dummyPart';
+
+export class PanelPart extends DummyPart implements IPanelService {
+	constructor(
+		@IThemeService themeService: IThemeService,
+		@IStorageService storageService: IStorageService,
+		@IWorkbenchLayoutService layoutService: IWorkbenchLayoutService) {
+		super(Parts.PANEL_PART, themeService, storageService, layoutService)
+	}
+
+	declare readonly _serviceBrand: undefined;
+
+	get onDidPanelOpen(): Event<{ panel: IPanel, focus: boolean; }> { return this.onDidOpenEvent() }
+
+	get onDidPanelClose() { return Event.None }
+
+	openPanel(id?: string, focus?: boolean): Promise<IPanel | undefined> {
+		return Promise.resolve(undefined)
+	}
+
+	getActivePanel(): IPanel | undefined { return undefined }
+
+	getPanel(id: string): IPanelIdentifier | undefined { return undefined }
+
+	getPanels(): readonly IPanelIdentifier[] { return [] }
+
+	getPinnedPanels(): readonly IPanelIdentifier[] { return [] }
+
+	getProgressIndicator(id: string): IProgressIndicator | undefined { return undefined }
+
+	showActivity(panelId: string, badge: IBadge, clazz?: string): IDisposable { return Disposable.None }
+
+	hideActivePanel(): void { }
+
+	getLastActivePanelId(): string { return '' }
+}
diff --git a/src/vs/workbench/browser/parts/dummies/sidebarPart.ts b/src/vs/workbench/browser/parts/dummies/sidebarPart.ts
new file mode 100644
index 0000000000..6bb6143484
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/sidebarPart.ts
@@ -0,0 +1,43 @@
+import { Event } from 'vs/base/common/event';
+import { IProgressIndicator } from 'vs/platform/progress/common/progress';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { DummyPart } from 'vs/workbench/browser/parts/dummies/dummyPart';
+import { IViewletService } from 'vs/workbench/services/viewlet/browser/viewlet';
+import { ViewletDescriptor } from 'vs/workbench/browser/viewlet';
+import { IViewlet } from 'vs/workbench/common/viewlet';
+
+export class SidebarPart extends DummyPart implements IViewletService {
+	constructor(
+		@IThemeService themeService: IThemeService,
+		@IStorageService storageService: IStorageService,
+		@IWorkbenchLayoutService layoutService: IWorkbenchLayoutService) {
+		super(Parts.SIDEBAR_PART, themeService, storageService, layoutService)
+
+		this.setVisible(false)
+	}
+
+	declare readonly _serviceBrand: undefined;
+
+	get onDidViewletRegister(): Event<ViewletDescriptor> { return Event.None }
+	get onDidViewletDeregister(): Event<ViewletDescriptor> { return Event.None }
+	get onDidViewletOpen(): Event<IViewlet> { return this.onDidOpenEvent() }
+	get onDidViewletClose(): Event<IViewlet> { return Event.None }
+
+	openViewlet(id: string | undefined, focus?: boolean): Promise<IViewlet | undefined> {
+		return Promise.resolve(undefined)
+	}
+
+	getActiveViewlet(): IViewlet | undefined { return undefined }
+
+	getViewlet(id: string): ViewletDescriptor | undefined { return undefined }
+
+	getViewlets(): ViewletDescriptor[] { return [] }
+
+	getProgressIndicator(id: string): IProgressIndicator | undefined { return undefined }
+
+	hideActiveViewlet(): void { }
+
+	getLastActiveViewletId(): string { return '' }
+}
diff --git a/src/vs/workbench/browser/parts/dummies/statusbarPart.ts b/src/vs/workbench/browser/parts/dummies/statusbarPart.ts
new file mode 100644
index 0000000000..225cfe59c9
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/statusbarPart.ts
@@ -0,0 +1,35 @@
+import { Event } from 'vs/base/common/event';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { DummyPart } from 'vs/workbench/browser/parts/dummies/dummyPart';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+import { IStatusbarEntry, IStatusbarService, IStatusbarEntryAccessor, StatusbarAlignment } from 'vs/workbench/services/statusbar/common/statusbar';
+
+export class StatusbarPart extends DummyPart implements IStatusbarService {
+	readonly _serviceBrand: undefined;
+
+	constructor(
+		@IThemeService themeService: IThemeService,
+		@IStorageService storageService: IStorageService,
+		@IWorkbenchLayoutService layoutService: IWorkbenchLayoutService) {
+		super(Parts.STATUSBAR_PART, themeService, storageService, layoutService)
+
+		this.setVisible(false)
+	}
+
+	addEntry(entry: IStatusbarEntry, id: string, name: string, alignment: StatusbarAlignment, priority?: number): IStatusbarEntryAccessor {
+		return dummyStatusbarEntryAccessor
+	}
+
+	get onDidChangeEntryVisibility(): Event<{ id: string, visible: boolean }> { return this.onDidOpenEvent() }
+	isEntryVisible(id: string): boolean { return false }
+	updateEntryVisibility(id: string, visible: boolean): void { }
+	focus(preserveEntryFocus?: boolean): void { }
+	focusNextEntry(): void { }
+	focusPreviousEntry(): void { }
+}
+
+const dummyStatusbarEntryAccessor: IStatusbarEntryAccessor = {
+	dispose() { },
+	update(properties: IStatusbarEntry): void { }
+}
diff --git a/src/vs/workbench/browser/parts/dummies/titlebarPart.ts b/src/vs/workbench/browser/parts/dummies/titlebarPart.ts
new file mode 100644
index 0000000000..4466b0a054
--- /dev/null
+++ b/src/vs/workbench/browser/parts/dummies/titlebarPart.ts
@@ -0,0 +1,25 @@
+import { Event } from 'vs/base/common/event';
+import { IStorageService } from 'vs/platform/storage/common/storage';
+import { IThemeService } from 'vs/platform/theme/common/themeService';
+import { DummyPart } from 'vs/workbench/browser/parts/dummies/dummyPart';
+import { IWorkbenchLayoutService, Parts } from 'vs/workbench/services/layout/browser/layoutService';
+import { ITitleProperties, ITitleService } from 'vs/workbench/services/title/common/titleService';
+
+export class TitlebarPart extends DummyPart implements ITitleService {
+	declare readonly _serviceBrand: undefined;
+
+	constructor(
+		@IThemeService themeService: IThemeService,
+		@IStorageService storageService: IStorageService,
+		@IWorkbenchLayoutService layoutService: IWorkbenchLayoutService) {
+		super(Parts.TITLEBAR_PART, themeService, storageService, layoutService)
+
+		this.setVisible(false)
+	}
+
+	get onMenubarVisibilityChange(): Event<boolean> {
+		return Event.None
+	}
+
+	updateProperties(properties: ITitleProperties): void { }
+}
diff --git a/yarn.lock b/yarn.lock
index d546267393..685eae4436 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -1210,7 +1210,7 @@ async-settle@^1.0.0:
   dependencies:
     async-done "^1.2.2"
 
-async@^2.1.5:
+async@^2.1.4, async@^2.1.5:
   version "2.6.3"
   resolved "https://registry.yarnpkg.com/async/-/async-2.6.3.tgz#d72625e2344a3656e3a3ad4fa749fa83299d82ff"
   integrity sha512-zflvls11DCy+dQWzTW2dzuilv8Z5X/pjfmZOWba6TNIVDm+2UDaJmXSOXlasHKfNBs8oo3M0aT50fDEWfKZjXg==
@@ -1437,6 +1437,14 @@ browser-stdout@1.3.1:
   resolved "https://registry.yarnpkg.com/browser-stdout/-/browser-stdout-1.3.1.tgz#baa559ee14ced73452229bad7326467c61fabd60"
   integrity sha512-qhAVI1+Av2X7qelOfAIYwXONood6XlZE/fXaBSmW/T5SzLAmCgzi+eiWE7fUvbHaeNBQH13UftjpXxsfLkMpgw==
 
+browserfs@1.4.3:
+  version "1.4.3"
+  resolved "https://registry.yarnpkg.com/browserfs/-/browserfs-1.4.3.tgz#92ffc6063967612daccdb8566d3fc03f521205fb"
+  integrity sha512-tz8HClVrzTJshcyIu8frE15cjqjcBIu15Bezxsvl/i+6f59iNCN3kznlWjz0FEb3DlnDx3gW5szxeT6D1x0s0w==
+  dependencies:
+    async "^2.1.4"
+    pako "^1.0.4"
+
 browserify-aes@^1.0.0, browserify-aes@^1.0.4:
   version "1.2.0"
   resolved "https://registry.yarnpkg.com/browserify-aes/-/browserify-aes-1.2.0.tgz#326734642f403dabc3003209853bb70ad428ef48"
@@ -7013,7 +7021,7 @@ p-try@^2.0.0:
   resolved "https://registry.yarnpkg.com/p-try/-/p-try-2.2.0.tgz#cb2868540e313d61de58fafbe35ce9004d5540e6"
   integrity sha512-R4nPAVTAU0B9D35/Gk3uJf/7XYbQcyohSKdvAxIRSNghFl4e71hVoGnBNQz9cWaXxO2I10KTC+3jMdvvoKw6dQ==
 
-pako@~1.0.5:
+pako@^1.0.4, pako@~1.0.5:
   version "1.0.11"
   resolved "https://registry.yarnpkg.com/pako/-/pako-1.0.11.tgz#6c9599d340d54dfd3946380252a35705a6b992bf"
   integrity sha512-4hLB8Py4zZce5s4yd9XzopqwVv/yGNhV1Bl8NTmCq1763HeK2+EwVTv+leGeL13Dnh2wfbqowVPXCIO0z4taYw==
