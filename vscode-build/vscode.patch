diff --git a/build/gulpfile.compile.js b/build/gulpfile.compile.js
index c4947e76cbf..e46583b9073 100644
--- a/build/gulpfile.compile.js
+++ b/build/gulpfile.compile.js
@@ -22,7 +22,7 @@ function makeCompileBuildTask(disableMangle) {
 }
 
 // Full compile, including nls and inline sources in sourcemaps, mangling, minification, for build
-const compileBuildTask = task.define('compile-build', makeCompileBuildTask(false));
+const compileBuildTask = task.define('compile-build', makeCompileBuildTask(true));
 gulp.task(compileBuildTask);
 exports.compileBuildTask = compileBuildTask;
 
diff --git a/build/gulpfile.vscode.web.js b/build/gulpfile.vscode.web.js
index 50c7e6fb631..629a119108b 100644
--- a/build/gulpfile.vscode.web.js
+++ b/build/gulpfile.vscode.web.js
@@ -186,7 +186,7 @@ function packageTask(sourceFolderName, destinationFolderName) {
 		const json = require('gulp-json-editor');
 
 		const src = gulp.src(sourceFolderName + '/**', { base: '.' })
-			.pipe(rename(function (path) { path.dirname = path.dirname.replace(new RegExp('^' + sourceFolderName), 'out'); }));
+			.pipe(rename(function (path) { path.dirname = path.dirname.replace(new RegExp('^' + sourceFolderName), 'vscode'); }));
 
 		const extensions = gulp.src('.build/web/extensions/**', { base: '.build/web', dot: true });
 
diff --git a/package.json b/package.json
index 2103fe1fe1a..92954953615 100644
--- a/package.json
+++ b/package.json
@@ -96,10 +96,10 @@
     "kerberos": "^2.0.1",
     "minimist": "^1.2.6",
     "native-is-elevated": "0.7.0",
-    "native-keymap": "^3.3.5",
     "native-watchdog": "^1.4.1",
     "node-pty": "1.1.0-beta11",
     "tas-client-umd": "0.2.0",
+    "utopia-vscode-common": "file:../../utopia-vscode-common",
     "v8-inspect-profiler": "^0.1.1",
     "vscode-oniguruma": "1.7.0",
     "vscode-regexpp": "^3.1.0",
diff --git a/product.json b/product.json
index 27ae53fe16b..782dce05a93 100644
--- a/product.json
+++ b/product.json
@@ -1,84 +1,9 @@
 {
-	"nameShort": "Code - OSS",
-	"nameLong": "Code - OSS",
-	"applicationName": "code-oss",
-	"dataFolderName": ".vscode-oss",
-	"win32MutexName": "vscodeoss",
-	"licenseName": "MIT",
-	"licenseUrl": "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
-	"serverLicenseUrl": "https://github.com/microsoft/vscode/blob/main/LICENSE.txt",
-	"serverGreeting": [],
-	"serverLicense": [],
-	"serverLicensePrompt": "",
-	"serverApplicationName": "code-server-oss",
-	"serverDataFolderName": ".vscode-server-oss",
-	"tunnelApplicationName": "code-tunnel-oss",
-	"win32DirName": "Microsoft Code OSS",
-	"win32NameVersion": "Microsoft Code OSS",
-	"win32RegValueName": "CodeOSS",
-	"win32x64AppId": "{{D77B7E06-80BA-4137-BCF4-654B95CCEBC5}",
-	"win32arm64AppId": "{{D1ACE434-89C5-48D1-88D3-E2991DF85475}",
-	"win32x64UserAppId": "{{CC6B787D-37A0-49E8-AE24-8559A032BE0C}",
-	"win32arm64UserAppId": "{{3AEBF0C8-F733-4AD4-BADE-FDB816D53D7B}",
-	"win32AppUserModelId": "Microsoft.CodeOSS",
-	"win32ShellNameShort": "C&ode - OSS",
-	"win32TunnelServiceMutex": "vscodeoss-tunnelservice",
-	"win32TunnelMutex": "vscodeoss-tunnel",
-	"darwinBundleIdentifier": "com.visualstudio.code.oss",
-	"linuxIconName": "code-oss",
-	"licenseFileName": "LICENSE.txt",
-	"reportIssueUrl": "https://github.com/microsoft/vscode/issues/new",
-	"nodejsRepository": "https://nodejs.org",
-	"urlProtocol": "code-oss",
-	"webviewContentExternalBaseUrlTemplate": "https://{{uuid}}.vscode-cdn.net/insider/ef65ac1ba57f57f2a3961bfe94aa20481caca4c6/out/vs/workbench/contrib/webview/browser/pre/",
-	"builtInExtensions": [
-		{
-			"name": "ms-vscode.js-debug-companion",
-			"version": "1.1.2",
-			"sha256": "e034b8b41beb4e97e02c70f7175bd88abe66048374c2bd629f54bb33354bc2aa",
-			"repo": "https://github.com/microsoft/vscode-js-debug-companion",
-			"metadata": {
-				"id": "99cb0b7f-7354-4278-b8da-6cc79972169d",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		},
-		{
-			"name": "ms-vscode.js-debug",
-			"version": "1.91.0",
-			"sha256": "53b99146c7fa280f00c74414e09721530c622bf3e5eac2c967ddfb9906b51c80",
-			"repo": "https://github.com/microsoft/vscode-js-debug",
-			"metadata": {
-				"id": "25629058-ddac-4e17-abba-74678e126c5d",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		},
-		{
-			"name": "ms-vscode.vscode-js-profile-table",
-			"version": "1.0.9",
-			"sha256": "3b62ee4276a2bbea3fe230f94b1d5edd915b05966090ea56f882e1e0ab53e1a6",
-			"repo": "https://github.com/microsoft/vscode-js-profile-visualizer",
-			"metadata": {
-				"id": "7e52b41b-71ad-457b-ab7e-0620f1fc4feb",
-				"publisherId": {
-					"publisherId": "5f5636e7-69ed-4afe-b5d6-8d231fb3d3ee",
-					"publisherName": "ms-vscode",
-					"displayName": "Microsoft",
-					"flags": "verified"
-				},
-				"publisherDisplayName": "Microsoft"
-			}
-		}
-	]
-}
+	"productConfiguration": {
+		"nameShort": "Code Web",
+		"nameLong": "Code Web",
+		"applicationName": "code-web",
+		"dataFolderName": ".vscode-web",
+		"version": "1.62.0"
+	}
+}
\ No newline at end of file
diff --git a/src/vs/base/browser/dom.ts b/src/vs/base/browser/dom.ts
index 66d30c3aca3..7855e0d09dc 100644
--- a/src/vs/base/browser/dom.ts
+++ b/src/vs/base/browser/dom.ts
@@ -495,8 +495,11 @@ export function getClientArea(element: HTMLElement, fallback?: HTMLElement): Dim
 	if (fallback) {
 		return getClientArea(fallback);
 	}
-
-	throw new Error('Unable to figure out browser width and height');
+ 	// this Error would prevent VSCode from loading inside Utopia if the browser tab is not in the foreground
+ 	// throw new Error('Unable to figure out browser width and height');
+ 
+ 	// Instead, we just return 0 x 0, it seems to be fine
+ 	return new Dimension(0, 0);
 }
 
 class SizeUtils {
diff --git a/src/vs/code/browser/workbench/workbench.ts b/src/vs/code/browser/workbench/workbench.ts
index f8875029a8a..11ef2e6f48b 100644
--- a/src/vs/code/browser/workbench/workbench.ts
+++ b/src/vs/code/browser/workbench/workbench.ts
@@ -3,23 +3,23 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import { isStandalone } from 'vs/base/browser/browser';
+// import { isStandalone } from 'vs/base/browser/browser';
 import { mainWindow } from 'vs/base/browser/window';
-import { VSBuffer, decodeBase64, encodeBase64 } from 'vs/base/common/buffer';
-import { Emitter } from 'vs/base/common/event';
-import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
-import { parse } from 'vs/base/common/marshalling';
-import { Schemas } from 'vs/base/common/network';
-import { posix } from 'vs/base/common/path';
-import { isEqual } from 'vs/base/common/resources';
-import { ltrim } from 'vs/base/common/strings';
-import { URI, UriComponents } from 'vs/base/common/uri';
+// import { VSBuffer, decodeBase64, encodeBase64 } from 'vs/base/common/buffer';
+// import { Emitter } from 'vs/base/common/event';
+// import { Disposable, IDisposable } from 'vs/base/common/lifecycle';
+// import { parse } from 'vs/base/common/marshalling';
+// import { Schemas } from 'vs/base/common/network';
+// import { posix } from 'vs/base/common/path';
+// import { isEqual } from 'vs/base/common/resources';
+// import { ltrim } from 'vs/base/common/strings';
+import { URI /*, UriComponents */ } from 'vs/base/common/uri';
 import product from 'vs/platform/product/common/product';
 import { ISecretStorageProvider } from 'vs/platform/secrets/common/secrets';
-import { isFolderToOpen, isWorkspaceToOpen } from 'vs/platform/window/common/window';
+// import { isFolderToOpen, isWorkspaceToOpen } from 'vs/platform/window/common/window';
 import type { IWorkbenchConstructionOptions, IWorkspace, IWorkspaceProvider } from 'vs/workbench/browser/web.api';
 import { AuthenticationSessionInfo } from 'vs/workbench/services/authentication/browser/authenticationService';
-import type { IURLCallbackProvider } from 'vs/workbench/services/url/browser/urlService';
+// import type { IURLCallbackProvider } from 'vs/workbench/services/url/browser/urlService';
 import { create } from 'vs/workbench/workbench.web.main';
 
 interface ISecretStorageCrypto {
@@ -27,143 +27,143 @@ interface ISecretStorageCrypto {
 	unseal(data: string): Promise<string>;
 }
 
-class TransparentCrypto implements ISecretStorageCrypto {
-	async seal(data: string): Promise<string> {
-		return data;
-	}
-
-	async unseal(data: string): Promise<string> {
-		return data;
-	}
-}
-
-const enum AESConstants {
-	ALGORITHM = 'AES-GCM',
-	KEY_LENGTH = 256,
-	IV_LENGTH = 12,
-}
-
-class ServerKeyedAESCrypto implements ISecretStorageCrypto {
-	private _serverKey: Uint8Array | undefined;
-
-	/** Gets whether the algorithm is supported; requires a secure context */
-	public static supported() {
-		return !!crypto.subtle;
-	}
-
-	constructor(private readonly authEndpoint: string) { }
-
-	async seal(data: string): Promise<string> {
-		// Get a new key and IV on every change, to avoid the risk of reusing the same key and IV pair with AES-GCM
-		// (see also: https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams#properties)
-		const iv = mainWindow.crypto.getRandomValues(new Uint8Array(AESConstants.IV_LENGTH));
-		// crypto.getRandomValues isn't a good-enough PRNG to generate crypto keys, so we need to use crypto.subtle.generateKey and export the key instead
-		const clientKeyObj = await mainWindow.crypto.subtle.generateKey(
-			{ name: AESConstants.ALGORITHM as const, length: AESConstants.KEY_LENGTH as const },
-			true,
-			['encrypt', 'decrypt']
-		);
-
-		const clientKey = new Uint8Array(await mainWindow.crypto.subtle.exportKey('raw', clientKeyObj));
-		const key = await this.getKey(clientKey);
-		const dataUint8Array = new TextEncoder().encode(data);
-		const cipherText: ArrayBuffer = await mainWindow.crypto.subtle.encrypt(
-			{ name: AESConstants.ALGORITHM as const, iv },
-			key,
-			dataUint8Array
-		);
-
-		// Base64 encode the result and store the ciphertext, the key, and the IV in localStorage
-		// Note that the clientKey and IV don't need to be secret
-		const result = new Uint8Array([...clientKey, ...iv, ...new Uint8Array(cipherText)]);
-		return encodeBase64(VSBuffer.wrap(result));
-	}
-
-	async unseal(data: string): Promise<string> {
-		// encrypted should contain, in order: the key (32-byte), the IV for AES-GCM (12-byte) and the ciphertext (which has the GCM auth tag at the end)
-		// Minimum length must be 44 (key+IV length) + 16 bytes (1 block encrypted with AES - regardless of key size)
-		const dataUint8Array = decodeBase64(data);
-
-		if (dataUint8Array.byteLength < 60) {
-			throw Error('Invalid length for the value for credentials.crypto');
-		}
-
-		const keyLength = AESConstants.KEY_LENGTH / 8;
-		const clientKey = dataUint8Array.slice(0, keyLength);
-		const iv = dataUint8Array.slice(keyLength, keyLength + AESConstants.IV_LENGTH);
-		const cipherText = dataUint8Array.slice(keyLength + AESConstants.IV_LENGTH);
-
-		// Do the decryption and parse the result as JSON
-		const key = await this.getKey(clientKey.buffer);
-		const decrypted = await mainWindow.crypto.subtle.decrypt(
-			{ name: AESConstants.ALGORITHM as const, iv: iv.buffer },
-			key,
-			cipherText.buffer
-		);
-
-		return new TextDecoder().decode(new Uint8Array(decrypted));
-	}
-
-	/**
-	 * Given a clientKey, returns the CryptoKey object that is used to encrypt/decrypt the data.
-	 * The actual key is (clientKey XOR serverKey)
-	 */
-	private async getKey(clientKey: Uint8Array): Promise<CryptoKey> {
-		if (!clientKey || clientKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
-			throw Error('Invalid length for clientKey');
-		}
-
-		const serverKey = await this.getServerKeyPart();
-		const keyData = new Uint8Array(AESConstants.KEY_LENGTH / 8);
-
-		for (let i = 0; i < keyData.byteLength; i++) {
-			keyData[i] = clientKey[i]! ^ serverKey[i]!;
-		}
-
-		return mainWindow.crypto.subtle.importKey(
-			'raw',
-			keyData,
-			{
-				name: AESConstants.ALGORITHM as const,
-				length: AESConstants.KEY_LENGTH as const,
-			},
-			true,
-			['encrypt', 'decrypt']
-		);
-	}
-
-	private async getServerKeyPart(): Promise<Uint8Array> {
-		if (this._serverKey) {
-			return this._serverKey;
-		}
-
-		let attempt = 0;
-		let lastError: unknown | undefined;
-
-		while (attempt <= 3) {
-			try {
-				const res = await fetch(this.authEndpoint, { credentials: 'include', method: 'POST' });
-				if (!res.ok) {
-					throw new Error(res.statusText);
-				}
-				const serverKey = new Uint8Array(await await res.arrayBuffer());
-				if (serverKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
-					throw Error(`The key retrieved by the server is not ${AESConstants.KEY_LENGTH} bit long.`);
-				}
-				this._serverKey = serverKey;
-				return this._serverKey;
-			} catch (e) {
-				lastError = e;
-				attempt++;
-
-				// exponential backoff
-				await new Promise(resolve => setTimeout(resolve, attempt * attempt * 100));
-			}
-		}
-
-		throw lastError;
-	}
-}
+// class TransparentCrypto implements ISecretStorageCrypto {
+// 	async seal(data: string): Promise<string> {
+// 		return data;
+// 	}
+
+// 	async unseal(data: string): Promise<string> {
+// 		return data;
+// 	}
+// }
+
+// const enum AESConstants {
+// 	ALGORITHM = 'AES-GCM',
+// 	KEY_LENGTH = 256,
+// 	IV_LENGTH = 12,
+// }
+
+// class ServerKeyedAESCrypto implements ISecretStorageCrypto {
+// 	private _serverKey: Uint8Array | undefined;
+
+// 	/** Gets whether the algorithm is supported; requires a secure context */
+// 	public static supported() {
+// 		return !!crypto.subtle;
+// 	}
+
+// 	constructor(private readonly authEndpoint: string) { }
+
+// 	async seal(data: string): Promise<string> {
+// 		// Get a new key and IV on every change, to avoid the risk of reusing the same key and IV pair with AES-GCM
+// 		// (see also: https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams#properties)
+// 		const iv = mainWindow.crypto.getRandomValues(new Uint8Array(AESConstants.IV_LENGTH));
+// 		// crypto.getRandomValues isn't a good-enough PRNG to generate crypto keys, so we need to use crypto.subtle.generateKey and export the key instead
+// 		const clientKeyObj = await mainWindow.crypto.subtle.generateKey(
+// 			{ name: AESConstants.ALGORITHM as const, length: AESConstants.KEY_LENGTH as const },
+// 			true,
+// 			['encrypt', 'decrypt']
+// 		);
+
+// 		const clientKey = new Uint8Array(await mainWindow.crypto.subtle.exportKey('raw', clientKeyObj));
+// 		const key = await this.getKey(clientKey);
+// 		const dataUint8Array = new TextEncoder().encode(data);
+// 		const cipherText: ArrayBuffer = await mainWindow.crypto.subtle.encrypt(
+// 			{ name: AESConstants.ALGORITHM as const, iv },
+// 			key,
+// 			dataUint8Array
+// 		);
+
+// 		// Base64 encode the result and store the ciphertext, the key, and the IV in localStorage
+// 		// Note that the clientKey and IV don't need to be secret
+// 		const result = new Uint8Array([...clientKey, ...iv, ...new Uint8Array(cipherText)]);
+// 		return encodeBase64(VSBuffer.wrap(result));
+// 	}
+
+// 	async unseal(data: string): Promise<string> {
+// 		// encrypted should contain, in order: the key (32-byte), the IV for AES-GCM (12-byte) and the ciphertext (which has the GCM auth tag at the end)
+// 		// Minimum length must be 44 (key+IV length) + 16 bytes (1 block encrypted with AES - regardless of key size)
+// 		const dataUint8Array = decodeBase64(data);
+
+// 		if (dataUint8Array.byteLength < 60) {
+// 			throw Error('Invalid length for the value for credentials.crypto');
+// 		}
+
+// 		const keyLength = AESConstants.KEY_LENGTH / 8;
+// 		const clientKey = dataUint8Array.slice(0, keyLength);
+// 		const iv = dataUint8Array.slice(keyLength, keyLength + AESConstants.IV_LENGTH);
+// 		const cipherText = dataUint8Array.slice(keyLength + AESConstants.IV_LENGTH);
+
+// 		// Do the decryption and parse the result as JSON
+// 		const key = await this.getKey(clientKey.buffer);
+// 		const decrypted = await mainWindow.crypto.subtle.decrypt(
+// 			{ name: AESConstants.ALGORITHM as const, iv: iv.buffer },
+// 			key,
+// 			cipherText.buffer
+// 		);
+
+// 		return new TextDecoder().decode(new Uint8Array(decrypted));
+// 	}
+
+// 	/**
+// 	 * Given a clientKey, returns the CryptoKey object that is used to encrypt/decrypt the data.
+// 	 * The actual key is (clientKey XOR serverKey)
+// 	 */
+// 	private async getKey(clientKey: Uint8Array): Promise<CryptoKey> {
+// 		if (!clientKey || clientKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
+// 			throw Error('Invalid length for clientKey');
+// 		}
+
+// 		const serverKey = await this.getServerKeyPart();
+// 		const keyData = new Uint8Array(AESConstants.KEY_LENGTH / 8);
+
+// 		for (let i = 0; i < keyData.byteLength; i++) {
+// 			keyData[i] = clientKey[i]! ^ serverKey[i]!;
+// 		}
+
+// 		return mainWindow.crypto.subtle.importKey(
+// 			'raw',
+// 			keyData,
+// 			{
+// 				name: AESConstants.ALGORITHM as const,
+// 				length: AESConstants.KEY_LENGTH as const,
+// 			},
+// 			true,
+// 			['encrypt', 'decrypt']
+// 		);
+// 	}
+
+// 	private async getServerKeyPart(): Promise<Uint8Array> {
+// 		if (this._serverKey) {
+// 			return this._serverKey;
+// 		}
+
+// 		let attempt = 0;
+// 		let lastError: unknown | undefined;
+
+// 		while (attempt <= 3) {
+// 			try {
+// 				const res = await fetch(this.authEndpoint, { credentials: 'include', method: 'POST' });
+// 				if (!res.ok) {
+// 					throw new Error(res.statusText);
+// 				}
+// 				const serverKey = new Uint8Array(await await res.arrayBuffer());
+// 				if (serverKey.byteLength !== AESConstants.KEY_LENGTH / 8) {
+// 					throw Error(`The key retrieved by the server is not ${AESConstants.KEY_LENGTH} bit long.`);
+// 				}
+// 				this._serverKey = serverKey;
+// 				return this._serverKey;
+// 			} catch (e) {
+// 				lastError = e;
+// 				attempt++;
+
+// 				// exponential backoff
+// 				await new Promise(resolve => setTimeout(resolve, attempt * attempt * 100));
+// 			}
+// 		}
+
+// 		throw lastError;
+// 	}
+// }
 
 export class LocalStorageSecretStorageProvider implements ISecretStorageProvider {
 	private readonly _storageKey = 'secrets.provider';
@@ -257,332 +257,364 @@ export class LocalStorageSecretStorageProvider implements ISecretStorageProvider
 }
 
 
-class LocalStorageURLCallbackProvider extends Disposable implements IURLCallbackProvider {
-
-	private static REQUEST_ID = 0;
-
-	private static QUERY_KEYS: ('scheme' | 'authority' | 'path' | 'query' | 'fragment')[] = [
-		'scheme',
-		'authority',
-		'path',
-		'query',
-		'fragment'
-	];
-
-	private readonly _onCallback = this._register(new Emitter<URI>());
-	readonly onCallback = this._onCallback.event;
-
-	private pendingCallbacks = new Set<number>();
-	private lastTimeChecked = Date.now();
-	private checkCallbacksTimeout: unknown | undefined = undefined;
-	private onDidChangeLocalStorageDisposable: IDisposable | undefined;
-
-	constructor(private readonly _callbackRoute: string) {
-		super();
-	}
-
-	create(options: Partial<UriComponents> = {}): URI {
-		const id = ++LocalStorageURLCallbackProvider.REQUEST_ID;
-		const queryParams: string[] = [`vscode-reqid=${id}`];
-
-		for (const key of LocalStorageURLCallbackProvider.QUERY_KEYS) {
-			const value = options[key];
-
-			if (value) {
-				queryParams.push(`vscode-${key}=${encodeURIComponent(value)}`);
-			}
-		}
-
-		// TODO@joao remove eventually
-		// https://github.com/microsoft/vscode-dev/issues/62
-		// https://github.com/microsoft/vscode/blob/159479eb5ae451a66b5dac3c12d564f32f454796/extensions/github-authentication/src/githubServer.ts#L50-L50
-		if (!(options.authority === 'vscode.github-authentication' && options.path === '/dummy')) {
-			const key = `vscode-web.url-callbacks[${id}]`;
-			localStorage.removeItem(key);
-
-			this.pendingCallbacks.add(id);
-			this.startListening();
-		}
-
-		return URI.parse(mainWindow.location.href).with({ path: this._callbackRoute, query: queryParams.join('&') });
+// class LocalStorageURLCallbackProvider extends Disposable implements IURLCallbackProvider {
+
+// 	private static REQUEST_ID = 0;
+
+// 	private static QUERY_KEYS: ('scheme' | 'authority' | 'path' | 'query' | 'fragment')[] = [
+// 		'scheme',
+// 		'authority',
+// 		'path',
+// 		'query',
+// 		'fragment'
+// 	];
+
+// 	private readonly _onCallback = this._register(new Emitter<URI>());
+// 	readonly onCallback = this._onCallback.event;
+
+// 	private pendingCallbacks = new Set<number>();
+// 	private lastTimeChecked = Date.now();
+// 	private checkCallbacksTimeout: unknown | undefined = undefined;
+// 	private onDidChangeLocalStorageDisposable: IDisposable | undefined;
+
+// 	constructor(private readonly _callbackRoute: string) {
+// 		super();
+// 	}
+
+// 	create(options: Partial<UriComponents> = {}): URI {
+// 		const id = ++LocalStorageURLCallbackProvider.REQUEST_ID;
+// 		const queryParams: string[] = [`vscode-reqid=${id}`];
+
+// 		for (const key of LocalStorageURLCallbackProvider.QUERY_KEYS) {
+// 			const value = options[key];
+
+// 			if (value) {
+// 				queryParams.push(`vscode-${key}=${encodeURIComponent(value)}`);
+// 			}
+// 		}
+
+// 		// TODO@joao remove eventually
+// 		// https://github.com/microsoft/vscode-dev/issues/62
+// 		// https://github.com/microsoft/vscode/blob/159479eb5ae451a66b5dac3c12d564f32f454796/extensions/github-authentication/src/githubServer.ts#L50-L50
+// 		if (!(options.authority === 'vscode.github-authentication' && options.path === '/dummy')) {
+// 			const key = `vscode-web.url-callbacks[${id}]`;
+// 			localStorage.removeItem(key);
+
+// 			this.pendingCallbacks.add(id);
+// 			this.startListening();
+// 		}
+
+// 		return URI.parse(mainWindow.location.href).with({ path: this._callbackRoute, query: queryParams.join('&') });
+// 	}
+
+// 	private startListening(): void {
+// 		if (this.onDidChangeLocalStorageDisposable) {
+// 			return;
+// 		}
+
+// 		const fn = () => this.onDidChangeLocalStorage();
+// 		mainWindow.addEventListener('storage', fn);
+// 		this.onDidChangeLocalStorageDisposable = { dispose: () => mainWindow.removeEventListener('storage', fn) };
+// 	}
+
+// 	private stopListening(): void {
+// 		this.onDidChangeLocalStorageDisposable?.dispose();
+// 		this.onDidChangeLocalStorageDisposable = undefined;
+// 	}
+
+// 	// this fires every time local storage changes, but we
+// 	// don't want to check more often than once a second
+// 	private async onDidChangeLocalStorage(): Promise<void> {
+// 		const ellapsed = Date.now() - this.lastTimeChecked;
+
+// 		if (ellapsed > 1000) {
+// 			this.checkCallbacks();
+// 		} else if (this.checkCallbacksTimeout === undefined) {
+// 			this.checkCallbacksTimeout = setTimeout(() => {
+// 				this.checkCallbacksTimeout = undefined;
+// 				this.checkCallbacks();
+// 			}, 1000 - ellapsed);
+// 		}
+// 	}
+
+// 	private checkCallbacks(): void {
+// 		let pendingCallbacks: Set<number> | undefined;
+
+// 		for (const id of this.pendingCallbacks) {
+// 			const key = `vscode-web.url-callbacks[${id}]`;
+// 			const result = localStorage.getItem(key);
+
+// 			if (result !== null) {
+// 				try {
+// 					this._onCallback.fire(URI.revive(JSON.parse(result)));
+// 				} catch (error) {
+// 					console.error(error);
+// 				}
+
+// 				pendingCallbacks = pendingCallbacks ?? new Set(this.pendingCallbacks);
+// 				pendingCallbacks.delete(id);
+// 				localStorage.removeItem(key);
+// 			}
+// 		}
+
+// 		if (pendingCallbacks) {
+// 			this.pendingCallbacks = pendingCallbacks;
+
+// 			if (this.pendingCallbacks.size === 0) {
+// 				this.stopListening();
+// 			}
+// 		}
+
+// 		this.lastTimeChecked = Date.now();
+// 	}
+// }
+
+// class WorkspaceProvider implements IWorkspaceProvider {
+
+// 	private static QUERY_PARAM_EMPTY_WINDOW = 'ew';
+// 	private static QUERY_PARAM_FOLDER = 'folder';
+// 	private static QUERY_PARAM_WORKSPACE = 'workspace';
+
+// 	private static QUERY_PARAM_PAYLOAD = 'payload';
+
+// 	static create(config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents }) {
+// 		let foundWorkspace = false;
+// 		let workspace: IWorkspace;
+// 		let payload = Object.create(null);
+
+// 		const query = new URL(document.location.href).searchParams;
+// 		query.forEach((value, key) => {
+// 			switch (key) {
+
+// 				// Folder
+// 				case WorkspaceProvider.QUERY_PARAM_FOLDER:
+// 					if (config.remoteAuthority && value.startsWith(posix.sep)) {
+// 						// when connected to a remote and having a value
+// 						// that is a path (begins with a `/`), assume this
+// 						// is a vscode-remote resource as simplified URL.
+// 						workspace = { folderUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
+// 					} else {
+// 						workspace = { folderUri: URI.parse(value) };
+// 					}
+// 					foundWorkspace = true;
+// 					break;
+
+// 				// Workspace
+// 				case WorkspaceProvider.QUERY_PARAM_WORKSPACE:
+// 					if (config.remoteAuthority && value.startsWith(posix.sep)) {
+// 						// when connected to a remote and having a value
+// 						// that is a path (begins with a `/`), assume this
+// 						// is a vscode-remote resource as simplified URL.
+// 						workspace = { workspaceUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
+// 					} else {
+// 						workspace = { workspaceUri: URI.parse(value) };
+// 					}
+// 					foundWorkspace = true;
+// 					break;
+
+// 				// Empty
+// 				case WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:
+// 					workspace = undefined;
+// 					foundWorkspace = true;
+// 					break;
+
+// 				// Payload
+// 				case WorkspaceProvider.QUERY_PARAM_PAYLOAD:
+// 					try {
+// 						payload = parse(value); // use marshalling#parse() to revive potential URIs
+// 					} catch (error) {
+// 						console.error(error); // possible invalid JSON
+// 					}
+// 					break;
+// 			}
+// 		});
+
+// 		// If no workspace is provided through the URL, check for config
+// 		// attribute from server
+// 		if (!foundWorkspace) {
+// 			if (config.folderUri) {
+// 				workspace = { folderUri: URI.revive(config.folderUri) };
+// 			} else if (config.workspaceUri) {
+// 				workspace = { workspaceUri: URI.revive(config.workspaceUri) };
+// 			}
+// 		}
+
+// 		return new WorkspaceProvider(workspace, payload, config);
+// 	}
+
+// 	readonly trusted = true;
+
+// 	private constructor(
+// 		readonly workspace: IWorkspace,
+// 		readonly payload: object,
+// 		private readonly config: IWorkbenchConstructionOptions
+// 	) {
+// 	}
+
+// 	async open(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): Promise<boolean> {
+// 		if (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {
+// 			return true; // return early if workspace and environment is not changing and we are reusing window
+// 		}
+
+// 		const targetHref = this.createTargetUrl(workspace, options);
+// 		if (targetHref) {
+// 			if (options?.reuse) {
+// 				mainWindow.location.href = targetHref;
+// 				return true;
+// 			} else {
+// 				let result;
+// 				if (isStandalone()) {
+// 					result = mainWindow.open(targetHref, '_blank', 'toolbar=no'); // ensures to open another 'standalone' window!
+// 				} else {
+// 					result = mainWindow.open(targetHref);
+// 				}
+
+// 				return !!result;
+// 			}
+// 		}
+// 		return false;
+// 	}
+
+// 	private createTargetUrl(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): string | undefined {
+
+// 		// Empty
+// 		let targetHref: string | undefined = undefined;
+// 		if (!workspace) {
+// 			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;
+// 		}
+
+// 		// Folder
+// 		else if (isFolderToOpen(workspace)) {
+// 			const queryParamFolder = this.encodeWorkspacePath(workspace.folderUri);
+// 			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${queryParamFolder}`;
+// 		}
+
+// 		// Workspace
+// 		else if (isWorkspaceToOpen(workspace)) {
+// 			const queryParamWorkspace = this.encodeWorkspacePath(workspace.workspaceUri);
+// 			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${queryParamWorkspace}`;
+// 		}
+
+// 		// Append payload if any
+// 		if (options?.payload) {
+// 			targetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;
+// 		}
+
+// 		return targetHref;
+// 	}
+
+// 	private encodeWorkspacePath(uri: URI): string {
+// 		if (this.config.remoteAuthority && uri.scheme === Schemas.vscodeRemote) {
+
+// 			// when connected to a remote and having a folder
+// 			// or workspace for that remote, only use the path
+// 			// as query value to form shorter, nicer URLs.
+// 			// however, we still need to `encodeURIComponent`
+// 			// to ensure to preserve special characters, such
+// 			// as `+` in the path.
+
+// 			return encodeURIComponent(`${posix.sep}${ltrim(uri.path, posix.sep)}`).replaceAll('%2F', '/');
+// 		}
+
+// 		return encodeURIComponent(uri.toString(true));
+// 	}
+
+// 	private isSame(workspaceA: IWorkspace, workspaceB: IWorkspace): boolean {
+// 		if (!workspaceA || !workspaceB) {
+// 			return workspaceA === workspaceB; // both empty
+// 		}
+
+// 		if (isFolderToOpen(workspaceA) && isFolderToOpen(workspaceB)) {
+// 			return isEqual(workspaceA.folderUri, workspaceB.folderUri); // same workspace
+// 		}
+
+// 		if (isWorkspaceToOpen(workspaceA) && isWorkspaceToOpen(workspaceB)) {
+// 			return isEqual(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace
+// 		}
+
+// 		return false;
+// 	}
+
+// 	hasRemote(): boolean {
+// 		if (this.workspace) {
+// 			if (isFolderToOpen(this.workspace)) {
+// 				return this.workspace.folderUri.scheme === Schemas.vscodeRemote;
+// 			}
+
+// 			if (isWorkspaceToOpen(this.workspace)) {
+// 				return this.workspace.workspaceUri.scheme === Schemas.vscodeRemote;
+// 			}
+// 		}
+
+// 		return true;
+// 	}
+// }
+
+// function readCookie(name: string): string | undefined {
+// 	const cookies = document.cookie.split('; ');
+// 	for (const cookie of cookies) {
+// 		if (cookie.startsWith(name + '=')) {
+// 			return cookie.substring(name.length + 1);
+// 		}
+// 	}
+
+// 	return undefined;
+// }
+
+(async function () {
+	// create workbench
+	const result = await fetch('/vscode/product.json')
+	const loadedConfig: IWorkbenchConstructionOptions = await result.json()
+
+	// Inject project specific utopia config into the product.json
+	const urlParams = new URLSearchParams(window.location.search)
+	const vsCodeSessionID = urlParams.get('vs_code_session_id')!
+
+	// Use this instance as the webview provider rather than hitting MS servers
+	const webviewEndpoint = `${window.location.origin}/vscode/vscode/vs/workbench/contrib/webview/browser/pre`
+
+	let config = {
+		...loadedConfig,
+		folderUri: {
+			scheme: vsCodeSessionID,
+			authority: '',
+			path: `/`,
+			query: '',
+			fragment: '',
+		},
+		webviewEndpoint: webviewEndpoint,
 	}
 
-	private startListening(): void {
-		if (this.onDidChangeLocalStorageDisposable) {
-			return;
-		}
-
-		const fn = () => this.onDidChangeLocalStorage();
-		mainWindow.addEventListener('storage', fn);
-		this.onDidChangeLocalStorageDisposable = { dispose: () => mainWindow.removeEventListener('storage', fn) };
-	}
+	const workspace = { folderUri: URI.revive(config.folderUri) }
 
-	private stopListening(): void {
-		this.onDidChangeLocalStorageDisposable?.dispose();
-		this.onDidChangeLocalStorageDisposable = undefined;
-	}
-
-	// this fires every time local storage changes, but we
-	// don't want to check more often than once a second
-	private async onDidChangeLocalStorage(): Promise<void> {
-		const ellapsed = Date.now() - this.lastTimeChecked;
-
-		if (ellapsed > 1000) {
-			this.checkCallbacks();
-		} else if (this.checkCallbacksTimeout === undefined) {
-			this.checkCallbacksTimeout = setTimeout(() => {
-				this.checkCallbacksTimeout = undefined;
-				this.checkCallbacks();
-			}, 1000 - ellapsed);
+	if (workspace) {
+		const workspaceProvider: IWorkspaceProvider = { 
+			workspace,
+			open: async (workspace: IWorkspace, options?: { reuse?: boolean, payload?: object }) => true,
+			trusted: true 
 		}
+		config = { ...config, workspaceProvider }
 	}
 
-	private checkCallbacks(): void {
-		let pendingCallbacks: Set<number> | undefined;
+	// setupVSCodeEventListenersForProject(vsCodeSessionID)
 
-		for (const id of this.pendingCallbacks) {
-			const key = `vscode-web.url-callbacks[${id}]`;
-			const result = localStorage.getItem(key);
+	create(mainWindow.document.body, config)
 
-			if (result !== null) {
-				try {
-					this._onCallback.fire(URI.revive(JSON.parse(result)));
-				} catch (error) {
-					console.error(error);
-				}
 
-				pendingCallbacks = pendingCallbacks ?? new Set(this.pendingCallbacks);
-				pendingCallbacks.delete(id);
-				localStorage.removeItem(key);
-			}
-		}
+	// const config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents; callbackRoute: string } = JSON.parse(configElementAttribute);
+	// const secretStorageKeyPath = readCookie('vscode-secret-key-path');
+	// const secretStorageCrypto = secretStorageKeyPath && ServerKeyedAESCrypto.supported()
+	// 	? new ServerKeyedAESCrypto(secretStorageKeyPath) : new TransparentCrypto();
 
-		if (pendingCallbacks) {
-			this.pendingCallbacks = pendingCallbacks;
-
-			if (this.pendingCallbacks.size === 0) {
-				this.stopListening();
-			}
-		}
-
-		this.lastTimeChecked = Date.now();
-	}
-}
-
-class WorkspaceProvider implements IWorkspaceProvider {
-
-	private static QUERY_PARAM_EMPTY_WINDOW = 'ew';
-	private static QUERY_PARAM_FOLDER = 'folder';
-	private static QUERY_PARAM_WORKSPACE = 'workspace';
-
-	private static QUERY_PARAM_PAYLOAD = 'payload';
-
-	static create(config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents }) {
-		let foundWorkspace = false;
-		let workspace: IWorkspace;
-		let payload = Object.create(null);
-
-		const query = new URL(document.location.href).searchParams;
-		query.forEach((value, key) => {
-			switch (key) {
-
-				// Folder
-				case WorkspaceProvider.QUERY_PARAM_FOLDER:
-					if (config.remoteAuthority && value.startsWith(posix.sep)) {
-						// when connected to a remote and having a value
-						// that is a path (begins with a `/`), assume this
-						// is a vscode-remote resource as simplified URL.
-						workspace = { folderUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
-					} else {
-						workspace = { folderUri: URI.parse(value) };
-					}
-					foundWorkspace = true;
-					break;
-
-				// Workspace
-				case WorkspaceProvider.QUERY_PARAM_WORKSPACE:
-					if (config.remoteAuthority && value.startsWith(posix.sep)) {
-						// when connected to a remote and having a value
-						// that is a path (begins with a `/`), assume this
-						// is a vscode-remote resource as simplified URL.
-						workspace = { workspaceUri: URI.from({ scheme: Schemas.vscodeRemote, path: value, authority: config.remoteAuthority }) };
-					} else {
-						workspace = { workspaceUri: URI.parse(value) };
-					}
-					foundWorkspace = true;
-					break;
-
-				// Empty
-				case WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW:
-					workspace = undefined;
-					foundWorkspace = true;
-					break;
-
-				// Payload
-				case WorkspaceProvider.QUERY_PARAM_PAYLOAD:
-					try {
-						payload = parse(value); // use marshalling#parse() to revive potential URIs
-					} catch (error) {
-						console.error(error); // possible invalid JSON
-					}
-					break;
-			}
-		});
-
-		// If no workspace is provided through the URL, check for config
-		// attribute from server
-		if (!foundWorkspace) {
-			if (config.folderUri) {
-				workspace = { folderUri: URI.revive(config.folderUri) };
-			} else if (config.workspaceUri) {
-				workspace = { workspaceUri: URI.revive(config.workspaceUri) };
-			}
-		}
-
-		return new WorkspaceProvider(workspace, payload, config);
-	}
-
-	readonly trusted = true;
-
-	private constructor(
-		readonly workspace: IWorkspace,
-		readonly payload: object,
-		private readonly config: IWorkbenchConstructionOptions
-	) {
-	}
-
-	async open(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): Promise<boolean> {
-		if (options?.reuse && !options.payload && this.isSame(this.workspace, workspace)) {
-			return true; // return early if workspace and environment is not changing and we are reusing window
-		}
-
-		const targetHref = this.createTargetUrl(workspace, options);
-		if (targetHref) {
-			if (options?.reuse) {
-				mainWindow.location.href = targetHref;
-				return true;
-			} else {
-				let result;
-				if (isStandalone()) {
-					result = mainWindow.open(targetHref, '_blank', 'toolbar=no'); // ensures to open another 'standalone' window!
-				} else {
-					result = mainWindow.open(targetHref);
-				}
-
-				return !!result;
-			}
-		}
-		return false;
-	}
-
-	private createTargetUrl(workspace: IWorkspace, options?: { reuse?: boolean; payload?: object }): string | undefined {
-
-		// Empty
-		let targetHref: string | undefined = undefined;
-		if (!workspace) {
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_EMPTY_WINDOW}=true`;
-		}
-
-		// Folder
-		else if (isFolderToOpen(workspace)) {
-			const queryParamFolder = this.encodeWorkspacePath(workspace.folderUri);
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_FOLDER}=${queryParamFolder}`;
-		}
-
-		// Workspace
-		else if (isWorkspaceToOpen(workspace)) {
-			const queryParamWorkspace = this.encodeWorkspacePath(workspace.workspaceUri);
-			targetHref = `${document.location.origin}${document.location.pathname}?${WorkspaceProvider.QUERY_PARAM_WORKSPACE}=${queryParamWorkspace}`;
-		}
-
-		// Append payload if any
-		if (options?.payload) {
-			targetHref += `&${WorkspaceProvider.QUERY_PARAM_PAYLOAD}=${encodeURIComponent(JSON.stringify(options.payload))}`;
-		}
-
-		return targetHref;
-	}
-
-	private encodeWorkspacePath(uri: URI): string {
-		if (this.config.remoteAuthority && uri.scheme === Schemas.vscodeRemote) {
-
-			// when connected to a remote and having a folder
-			// or workspace for that remote, only use the path
-			// as query value to form shorter, nicer URLs.
-			// however, we still need to `encodeURIComponent`
-			// to ensure to preserve special characters, such
-			// as `+` in the path.
-
-			return encodeURIComponent(`${posix.sep}${ltrim(uri.path, posix.sep)}`).replaceAll('%2F', '/');
-		}
-
-		return encodeURIComponent(uri.toString(true));
-	}
-
-	private isSame(workspaceA: IWorkspace, workspaceB: IWorkspace): boolean {
-		if (!workspaceA || !workspaceB) {
-			return workspaceA === workspaceB; // both empty
-		}
-
-		if (isFolderToOpen(workspaceA) && isFolderToOpen(workspaceB)) {
-			return isEqual(workspaceA.folderUri, workspaceB.folderUri); // same workspace
-		}
-
-		if (isWorkspaceToOpen(workspaceA) && isWorkspaceToOpen(workspaceB)) {
-			return isEqual(workspaceA.workspaceUri, workspaceB.workspaceUri); // same workspace
-		}
-
-		return false;
-	}
-
-	hasRemote(): boolean {
-		if (this.workspace) {
-			if (isFolderToOpen(this.workspace)) {
-				return this.workspace.folderUri.scheme === Schemas.vscodeRemote;
-			}
-
-			if (isWorkspaceToOpen(this.workspace)) {
-				return this.workspace.workspaceUri.scheme === Schemas.vscodeRemote;
-			}
-		}
-
-		return true;
-	}
-}
-
-function readCookie(name: string): string | undefined {
-	const cookies = document.cookie.split('; ');
-	for (const cookie of cookies) {
-		if (cookie.startsWith(name + '=')) {
-			return cookie.substring(name.length + 1);
-		}
-	}
-
-	return undefined;
-}
-
-(function () {
-
-	// Find config by checking for DOM
-	const configElement = mainWindow.document.getElementById('vscode-workbench-web-configuration');
-	const configElementAttribute = configElement ? configElement.getAttribute('data-settings') : undefined;
-	if (!configElement || !configElementAttribute) {
-		throw new Error('Missing web configuration element');
-	}
-	const config: IWorkbenchConstructionOptions & { folderUri?: UriComponents; workspaceUri?: UriComponents; callbackRoute: string } = JSON.parse(configElementAttribute);
-	const secretStorageKeyPath = readCookie('vscode-secret-key-path');
-	const secretStorageCrypto = secretStorageKeyPath && ServerKeyedAESCrypto.supported()
-		? new ServerKeyedAESCrypto(secretStorageKeyPath) : new TransparentCrypto();
-
-	// Create workbench
-	create(mainWindow.document.body, {
-		...config,
-		windowIndicator: config.windowIndicator ?? { label: '$(remote)', tooltip: `${product.nameShort} Web` },
-		settingsSyncOptions: config.settingsSyncOptions ? { enabled: config.settingsSyncOptions.enabled, } : undefined,
-		workspaceProvider: WorkspaceProvider.create(config),
-		urlCallbackProvider: new LocalStorageURLCallbackProvider(config.callbackRoute),
-		secretStorageProvider: config.remoteAuthority && !secretStorageKeyPath
-			? undefined /* with a remote without embedder-preferred storage, store on the remote */
-			: new LocalStorageSecretStorageProvider(secretStorageCrypto),
-	});
+	// // Create workbench
+	// create(mainWindow.document.body, {
+	// 	...config,
+	// 	windowIndicator: config.windowIndicator ?? { label: '$(remote)', tooltip: `${product.nameShort} Web` },
+	// 	settingsSyncOptions: config.settingsSyncOptions ? { enabled: config.settingsSyncOptions.enabled, } : undefined,
+	// 	workspaceProvider: WorkspaceProvider.create(config),
+	// 	urlCallbackProvider: new LocalStorageURLCallbackProvider(config.callbackRoute),
+	// 	secretStorageProvider: config.remoteAuthority && !secretStorageKeyPath
+	// 		? undefined /* with a remote without embedder-preferred storage, store on the remote */
+	// 		: new LocalStorageSecretStorageProvider(secretStorageCrypto),
+	// });
 })();
diff --git a/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts b/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
index 81db8b47267..f1ae397d77c 100644
--- a/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
+++ b/src/vs/platform/environment/test/node/nativeModules.integrationTest.ts
@@ -26,14 +26,6 @@ flakySuite('Native Modules (all platforms)', () => {
 		assert.ok(typeof result === 'boolean', testErrorMessage('native-is-elevated'));
 	});
 
-	test('native-keymap', async () => {
-		const keyMap = await import('native-keymap');
-		assert.ok(typeof keyMap.getCurrentKeyboardLayout === 'function', testErrorMessage('native-keymap'));
-
-		const result = keyMap.getCurrentKeyboardLayout();
-		assert.ok(result, testErrorMessage('native-keymap'));
-	});
-
 	test('native-watchdog', async () => {
 		const watchDog = await import('native-watchdog');
 		assert.ok(typeof watchDog.start === 'function', testErrorMessage('native-watchdog'));
diff --git a/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts b/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
index 1d17e4c709e..00109563f5c 100644
--- a/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
+++ b/src/vs/platform/keyboardLayout/electron-main/keyboardLayoutMainService.ts
@@ -3,8 +3,6 @@
  *  Licensed under the MIT License. See License.txt in the project root for license information.
  *--------------------------------------------------------------------------------------------*/
 
-import type * as nativeKeymap from 'native-keymap';
-import * as platform from 'vs/base/common/platform';
 import { Emitter } from 'vs/base/common/event';
 import { Disposable } from 'vs/base/common/lifecycle';
 import { createDecorator } from 'vs/platform/instantiation/common/instantiation';
@@ -45,29 +43,10 @@ export class KeyboardLayoutMainService extends Disposable implements INativeKeyb
 		return this._initPromise;
 	}
 
-	private async _doInitialize(): Promise<void> {
-		const nativeKeymapMod = await import('native-keymap');
-
-		this._keyboardLayoutData = readKeyboardLayoutData(nativeKeymapMod);
-		if (!platform.isCI) {
-			// See https://github.com/microsoft/vscode/issues/152840
-			// Do not register the keyboard layout change listener in CI because it doesn't work
-			// on the build machines and it just adds noise to the build logs.
-			nativeKeymapMod.onDidChangeKeyboardLayout(() => {
-				this._keyboardLayoutData = readKeyboardLayoutData(nativeKeymapMod);
-				this._onDidChangeKeyboardLayout.fire(this._keyboardLayoutData);
-			});
-		}
-	}
+	private async _doInitialize(): Promise<void> {}
 
 	public async getKeyboardLayoutData(): Promise<IKeyboardLayoutData> {
 		await this._initialize();
 		return this._keyboardLayoutData!;
 	}
 }
-
-function readKeyboardLayoutData(nativeKeymapMod: typeof nativeKeymap): IKeyboardLayoutData {
-	const keyboardMapping = nativeKeymapMod.getKeyMap();
-	const keyboardLayoutInfo = nativeKeymapMod.getCurrentKeyboardLayout();
-	return { keyboardMapping, keyboardLayoutInfo };
-}
diff --git a/src/vs/workbench/browser/workbench.ts b/src/vs/workbench/browser/workbench.ts
index b0688133537..322777365eb 100644
--- a/src/vs/workbench/browser/workbench.ts
+++ b/src/vs/workbench/browser/workbench.ts
@@ -50,6 +50,8 @@ import { AccessibilityProgressSignalScheduler } from 'vs/platform/accessibilityS
 import { setProgressAcccessibilitySignalScheduler } from 'vs/base/browser/ui/progressbar/progressAccessibilitySignal';
 import { AccessibleViewRegistry } from 'vs/platform/accessibility/browser/accessibleViewRegistry';
 import { NotificationAccessibleView } from 'vs/workbench/browser/parts/notifications/notificationAccessibleView';
+import { ICommandService } from '../../platform/commands/common/commands';
+import { isDeletePathChange, isEnsureDirectoryExistsChange, isInitProject, isWriteProjectFileChange, messageListenersReady } from 'utopia-vscode-common';
 
 export interface IWorkbenchOptions {
 
@@ -193,6 +195,63 @@ export class Workbench extends Layout {
 				this.restore(lifecycleService);
 			});
 
+			// Chain off of the previous one to ensure the ordering of changes is maintained.
+			// FIXME Do we still need this?
+			let applyProjectChangesCoordinator: Promise<void> = Promise.resolve()
+
+			let intervalID: number | null = null
+
+			mainWindow.addEventListener('message', (messageEvent: MessageEvent) => {
+				const { data } = messageEvent;
+				if (isInitProject(data)) {
+					if (intervalID != null) {
+						window.clearInterval(intervalID)
+					}
+					console.log(`Received init message`)
+					// initIndexedDBBridge(vsCodeSessionID, data.projectContents, data.openFilePath)
+				} else if (isDeletePathChange(data)) {
+					applyProjectChangesCoordinator = applyProjectChangesCoordinator.then(async () => {
+						// await deletePath(toFSPath(data.fullPath), data.recursive)
+					})
+				} else if (isWriteProjectFileChange(data)) {
+					applyProjectChangesCoordinator = applyProjectChangesCoordinator.then(async () => {
+						// await writeProjectFile(data.projectFile)
+					})
+				} else if (isEnsureDirectoryExistsChange(data)) {
+					applyProjectChangesCoordinator = applyProjectChangesCoordinator.then(async () => {
+						// await ensureDirectoryExists(toFSPath(data.fullPath))
+					})
+					// FIXME we shouldn't differentiate these
+				// } else if (isToVSCodeExtensionMessage(data)) {
+				// 	applyProjectChangesCoordinator = applyProjectChangesCoordinator.then(async () => {
+				// 		// await sendMessage(data.message)
+				// 	})
+				}
+
+
+				if (typeof data === 'object') {
+					if ((data as any)?.['type'] === 'INIT_PROJECT') {
+						const commandService = this.serviceCollection.get(ICommandService);
+						if (commandService == null) {
+							console.log(`There is no command service`);
+						} else {
+							(commandService as ICommandService).executeCommand('memfs.workspaceInit');
+						}
+					}
+					else if ((data as any)?.['type'] === 'MEMFS_FILE_UPDATE') {
+						console.log(`There was a file update`, data);
+					}
+				}
+			});
+
+			intervalID = window.setInterval(() => {
+				try {
+					window.top?.postMessage(messageListenersReady(), '*')
+				} catch (error) {
+					console.error('Error posting messageListenersReady', error)
+				}
+			}, 500)
+
 			return instantiationService;
 		} catch (error) {
 			onUnexpectedError(error);
diff --git a/yarn.lock b/yarn.lock
index 71aef4295fa..7689f69b84e 100644
--- a/yarn.lock
+++ b/yarn.lock
@@ -7200,11 +7200,6 @@ native-is-elevated@0.7.0:
   resolved "https://registry.yarnpkg.com/native-is-elevated/-/native-is-elevated-0.7.0.tgz#77499639e232edad1886403969e2bf236294e7af"
   integrity sha512-tp8hUqK7vexBiyIWKMvmRxdG6kqUtO+3eay9iB0i16NYgvCqE5wMe1Y0guHilpkmRgvVXEWNW4et1+qqcwpLBA==
 
-native-keymap@^3.3.5:
-  version "3.3.5"
-  resolved "https://registry.yarnpkg.com/native-keymap/-/native-keymap-3.3.5.tgz#b1da65d32e42bf65e3ff9db05bed319927dc2b01"
-  integrity sha512-7XDOLPNX1FnUFC/cX3cioBz2M+dO212ai9DuwpfKFzkPu3xTmEzOm5xewOMLXE4V9YoRhNPxvq1H2YpPWDgSsg==
-
 native-watchdog@^1.4.1:
   version "1.4.2"
   resolved "https://registry.yarnpkg.com/native-watchdog/-/native-watchdog-1.4.2.tgz#cf9f913157ee992723aa372b6137293c663be9b7"
